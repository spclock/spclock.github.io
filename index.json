[{"categories":["数据库"],"content":"带你认识SqLite数据库 sqlite ","date":"2022-02-19","objectID":"/posts/sqlite/:0:0","tags":["sqlite"],"title":"SqLite","uri":"/posts/sqlite/"},{"categories":["数据库"],"content":"sqlite的锁 sqlite官方文件锁定和并发简介 unlocked:最初状态，未加锁，连接还没有开始访问数据库 shared:共享锁，多个连接可以同时获得并保持shared锁，即多个连接可以同时从同一个数据库中读数据。 reserved:保留锁，一个连接如果想要写数据库，必须首先获得一个reserved锁。一个数据库同时只能有一个reserved锁，该reserved锁可以与shared锁共存，它是写数据库的第一个阶段。reserved锁既不阻止其他拥有shared锁的连接继续读数据库，也不阻止其他连接获得新的shared锁。当一个连接获得了reserved锁，就可以开始处理数据库修改操作了。尽管这些修改只能在缓冲区进行，而不是实际写到磁盘，修改保存在内存缓冲区中。 pending:未决锁，当连接想要提交修改时，需要将reserved锁提升为pending锁。获得pending锁后，其他连接就不能再获得新的共享锁了，但已经拥有shared锁的连接仍然可以继续正常读数据库。此时，拥有reserved锁的连接等待其他拥有shared锁的连接完成工作并释放其共享锁。 exclusive:排它锁，一旦所有的其他共享锁都被释放，拥有pending锁的连接就可以将锁提升至exclusive锁，此时就可以自由地对数据库进行修改。所有以前所缓存的修改都会被写到数据库文件中。 ","date":"2022-02-19","objectID":"/posts/sqlite/:1:0","tags":["sqlite"],"title":"SqLite","uri":"/posts/sqlite/"},{"categories":["数据库"],"content":"SQLite事务类型 sqlite官方事务说明 SQLite有三种不同的事务类型： DEFERRED（推迟） MMEDIATE（立即） EXCLUSIVE（排它） 事务类型在BEGIN命令中指定。 一个deferred事务不获取任何锁，直到它需要锁的时候。而且BEGIN语句本身也不会做什么事情——它开始于UNLOCK状态；默认情况下是这样的。如果仅仅用BEGIN开始一个事务，那么事务就是DEFERRED的，同时它不会获取任何锁，当对数据库进行第一次读操作时，它会获取SHARED LOCK；同样，当进行第一次写操作时，它会获取RESERVED LOCK。 由BEGIN开始的Immediate事务会试着获取RESERVED LOCK。如果成功，BEGIN IMMEDIATE保证没有别的连接可以写数据库。但是，别的连接可以对数据库进行读操作，但是RESERVED LOCK会阻止其它的连接BEGIN IMMEDIATE或者BEGIN EXCLUSIVE命令，SQLite会返回SQLITE_BUSY错误。这时你就可以对数据库进行修改操作，但是你不能提交，当你COMMIT时，会返回SQLITE_BUSY错误，这意味着还有其它的读事务没有完成，得等它们执行完后才能提交事务。 Exclusive事务会试着获取对数据库的EXCLUSIVE锁。这与IMMEDIATE类似，但是一旦成功，EXCLUSIVE事务保证没有其它的连接，所以就可对数据库进行读写操作了。 上面那个例子的问题在于两个连接最终都想写数据库，但是他们都没有放弃各自原来的锁，最终，shared 锁导致了问题的出现。如果两个连接都以BEGIN IMMEDIATE开始事务，那么死锁就不会发生。在这种情况下，在同一时刻只能有一个连接进入BEGIN IMMEDIATE，其它的连接就得等待。BEGIN IMMEDIATE和BEGIN EXCLUSIVE通常被写事务使用。就像同步机制一样，它防止了死锁的产生。 基本的准则是：如果你在使用的数据库没有其它的连接，用BEGIN就足够了。但是，如果你使用的数据库在其它的连接也要对数据库进行写操作，就得使用BEGIN IMMEDIATE或BEGIN EXCLUSIVE开始你的事务 ","date":"2022-02-19","objectID":"/posts/sqlite/:2:0","tags":["sqlite"],"title":"SqLite","uri":"/posts/sqlite/"},{"categories":["数据库"],"content":"sqlite死锁 B连接执行INSERT语句时获得了reserved锁，reserved锁只有一个，而且它不会阻止其他连接获取shared锁；A连接执行SELECT语句获得shared锁；此时B连接进行commit，由于shared锁还未释放，B连接无法获得pending锁；A连接执行INSERT语句，想获取reserved锁，但是reserved锁只有一个且被B连接持有，所以A连接等待reserved锁；A连接shared锁一直没有释放，B连接就不能提升到exclusive锁，等待A连接释放shared锁。 使用正确的事务类型可以避免死锁。 一个DEFERRED事务不获取任何锁(直到它需要锁的时候)，BEGIN语句本身也不会做什么事情——它开始于UNLOCK状态。默认情况下就 是这样的，如果仅仅用BEGIN开始一个事务，那么事务就是DEFERRED的，同时它不会获取任何锁；当对数据库进行第一次读操作时，它会获取 SHARED锁；同样，当进行第一次写操作时，它会获取RESERVED锁。 由BEGIN开始的IMMEDIATE事务会尝试获取RESERVED锁。如果成功，BEGIN IMMEDIATE保证没有别的连接可以写数据库。但是，别的连接可以对数据库进行读操作；但是，RESERVED锁会阻止其它连接的BEGIN IMMEDIATE或者BEGIN EXCLUSIVE命令，当其它连接执行上述命令时，会返回SQLITE_BUSY 错误。这时你就可以对数据库进行修改操作了，但是你还不能提交，当你 COMMIT时，会返回SQLITE_BUSY错误，这意味着还有其它的读事务没有完成，得等它们执行完后才能提交事务。 EXCLUSIVE事务会试着获取对数据库的EXCLUSIVE锁。这与IMMEDIATE类似，但是一旦成功，EXCLUSIVE事务保证没有其它的连接，所以就可对数据库进行读写操作了。 注意：从3.7.0 (2010-07-21)版本开始，SQLite 也支持“ WAL 模式” 如果是 wal模式就没有以下死锁的问题，因为可以支持多读一写，因为隔离级别SERIALIZABLE（默认），所有读的是已提交的数据 连接1：BEGIN （UNLOCKED） 连接1：SELECT … （SHARED） 连接1：INSERT … （RESERVED） 连接2：BEGIN （UNLOCKED） 连接2：SELECT … （SHARED） 连接1：COMMIT （PENDING，尝试获取EXCLUSIVE锁，但还有SHARED锁未释放，返回SQLITE_BUSY） 连接2：INSERT … （尝试获取RESERVED锁，但已有PENDING锁未释放，返回SQLITE_BUSY） 现在2个连接都在等待对方释放锁，于是就死锁了。当然，实际情况并没那么糟糕，任何一方选择不继续等待，回滚事务就行了。 不过要更好地解决这个问题，就必须更深入地了解事务了。 实际上BEGIN语句可以有3种起始状态： DEFERRED：默认值，开始事务时不获取任何锁。进行第一次读操作时获取SHARED锁，进行第一次写操作时获取RESERVED锁。 IMMEDIATE：开始事务时获取RESERVED锁。 EXCLUSIVE：开始事务时获取EXCLUSIVE锁。 现在考虑2个事务在开始时都使用IMMEDIATE方式： 连接1：BEGIN IMMEDIATE （RESERVED） 连接1：SELECT … （RESERVED） 连接1：INSERT … （RESERVED） 连接2：BEGIN IMMEDIATE （尝试获取RESERVED锁，但已有RESERVED锁未释放，因此事务开始失败，返回SQLITE_BUSY，等待用户重试） 连接1：COMMIT （EXCLUSIVE，写入完成后释放） 连接2：BEGIN IMMEDIATE （RESERVED） 连接2：SELECT … （RESERVED） 连接2：INSERT … （RESERVED） 连接2：COMMIT （EXCLUSIVE，写入完成后释放） 这样死锁就被避免了。 而EXCLUSIVE方式则更为严苛，即使其他连接以DEFERRED方式开启事务也不会死锁： 连接1：BEGIN EXCLUSIVE （EXCLUSIVE） 连接1：SELECT … （EXCLUSIVE） 连接1：INSERT … （EXCLUSIVE） 连接2：BEGIN （UNLOCKED） 连接2：SELECT … （尝试获取SHARED锁，但已有EXCLUSIVE锁未释放，返回SQLITE_BUSY，等待用户重试） 连接1：COMMIT （EXCLUSIVE，写入完成后释放） 连接2：SELECT … （SHARED） 连接2：INSERT … （RESERVED） 连接2：COMMIT （EXCLUSIVE，写入完成后释放） 不过在并发很高的情况下，直接获取EXCLUSIVE锁的难度比较大；而且为了避免EXCLUSIVE状态长期阻塞其他请求，最好的方式还是让所有写事务都以IMMEDIATE方式开始。 顺带一提，要实现重试的话，可以使用sqlite3_busy_timeout()或sqlite3_busy_handler()函数。 由此可见，要想保证线程安全的话，可以有这4种方式： SQLite使用单线程模式，用一个专门的线程访问数据库。 SQLite使用单线程模式，用一个线程队列来访问数据库，队列一次只允许一个线程执行，队列里的线程共用一个数据库连接。 SQLite使用多线程模式，每个线程创建自己的数据库连接。 SQLite使用串行模式，所有线程共用全局的数据库连接。 ","date":"2022-02-19","objectID":"/posts/sqlite/:3:0","tags":["sqlite"],"title":"SqLite","uri":"/posts/sqlite/"},{"categories":["数据库"],"content":"[SQLITE_BUSY]sqlite Database is Locked解决办法 看完了上面介绍对数据库锁和事务也有一定的了解，那就应该知道为什么会报数据库锁上的原因 有多个连接操作数据库而读写使用不当造成的。 解决办法(以下例子是java服务器)： 简单粗暴：只有一个连接操作数据库 spring.datasource.hikari.maximum-pool-size=1 （wal模式）多个连接处理读 一个连接处理写 ，如果使用是事务就把整个事务当成写操作将锁前置到事务开始前上锁，事务提交或者回滚之后解锁，不然事务一并使用会有大坑。 @org.springframework.transaction.annotation.Transactional 不要与 一同使用会有死锁情况 private ReadWriteLock lock = new ReentrantReadWriteLock(); lock.writeLock().lock(); 类似问题transcation与synchroized 如果真的高并发需要用多个连接，需要考虑换别的数据库 默认情况下100-120qbs 如何提高并发量 https://zhuanlan.zhihu.com/p/36769649 SQlite支持库级并发， 即允许多个读事务同时运行， 同一时刻最多只有一个写事务， 读写冲突， sqlite隔离级别 SQLite 3.7版本后，对并发控制做了优化，推出了WAL日志模式，可以实现读写并发，但同一个时刻仍然只能有一个写事务。 ","date":"2022-02-19","objectID":"/posts/sqlite/:4:0","tags":["sqlite"],"title":"SqLite","uri":"/posts/sqlite/"},{"categories":["数据库"],"content":"sqilte wal模式 默认PRAGMA journal_mode=DELETE; 就会将sqlite改变成wal模式 #sql执行PRAGMAjournal_mode=WALmain 是 数据库？schema ","date":"2022-02-19","objectID":"/posts/sqlite/:5:0","tags":["sqlite"],"title":"SqLite","uri":"/posts/sqlite/"},{"categories":["数据库"],"content":"文件锁模式 官网locking_mode PRAGMA locking_mode = NORMAL | EXCLUSIVE sqlite参数说明好blog ","date":"2022-02-19","objectID":"/posts/sqlite/:6:0","tags":["sqlite"],"title":"SqLite","uri":"/posts/sqlite/"},{"categories":["java"],"content":"线程的管理是计算机资源管理的重要一环。减少每次获取资源的消耗，提高对资源的利用率。 线程池 创建很多很多的线程带来的问题： 内存开销 上下文切换开销 减少创建线程资源开销，线程不是越多越好，现在计算机分时操作系统，每一个线程都是由操作系统分配时间进行调度，每当一个线程时间片耗尽就会切换到别的线程执行，在这过程中线程切换（上下文切换）是会消耗资源。因此线程的复用是很有必要。 // 自定义创建线程池 ThreadPoolExecutor executor = new ThreadPoolExecutor( 5,//CORE_POOL_SIZE 10,//MAX_POOL_SIZE 1L,//KEEP_ALIVE_TIME TimeUnit.SECONDS, new ArrayBlockingQueue\u003c\u003e(100),//QUEUE_CAPACITY new ThreadPoolExecutor.CallerRunsPolicy()); //线程池执行任务 当然你也可以用lambda表达式 executor.execute(new Runnable() { @Override public void run() { System.out.println(\"execute task\"); } }); // 关闭线程池 executor.shutdown(); 有按个特别重要的参数： corePoolSize: 线程池中的核心线程数 maximumPoolSize: 线程池中可扩展到的最大线程数 workQueue: 当新的任务来的时候先判断当前的线程数是否达到corePoolSize核心线程数，如果达到就将任务存放在队列中。 keepAliveTime: 当线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁； unit : keepAliveTime 参数的时间单位。 threadFactory : executor 创建新线程的时候会用到。 handler : 饱和策略。关于饱和策略下面单独介绍一下。 ThreadPoolExecutor.AbortPolicy： 抛出 RejectedExecutionException来拒绝新任务的处理。 ThreadPoolExecutor.CallerRunsPolicy： 调用执行自己的线程运行任务，也就是直接在调用execute方法的线程中运行(run)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。 ThreadPoolExecutor.DiscardPolicy： 不处理新任务，直接丢弃掉。 ThreadPoolExecutor.DiscardOldestPolicy： 此策略将丢弃最早的未处理的任务请求。 线程的生命周期？ ","date":"2022-02-14","objectID":"/posts/%E7%BA%BF%E7%A8%8B%E6%B1%A0/:0:0","tags":["线程池"],"title":"线程池","uri":"/posts/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"},{"categories":["java"],"content":"那怎么实现当线程执行完任务能被复用 ","date":"2022-02-14","objectID":"/posts/%E7%BA%BF%E7%A8%8B%E6%B1%A0/:1:0","tags":["线程池"],"title":"线程池","uri":"/posts/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"},{"categories":["java"],"content":"线程池参数配置多少才合适 你得要考虑几个问题 这个线程池是拿来干什么任务的？ 任务类型是什么样的密集型？ **为什么要设置，将cpu利用最大化 ** CPU密集型： ​ 完成该项任务是多以cpu来计算为主，这时候cpu一直干活利用率很高，按理设置线程数=cpu核数+1加一是防止线程意外中断少利用cpu I/O密集型： 多以I/O为主的任务（网络io 文件io），cpu需要等待，这时候就要依据cpu利用率（I/O耗时 / CPU耗时） 例如： I/O耗时 ： CPU耗时 = 3 ：1 2核的cpu设置1+2*3+1=8 全是I/O操作就2n+1 （n是cpu的核数） PS：如果不明白看看《CPU这个世界太慢了》的文章 ","date":"2022-02-14","objectID":"/posts/%E7%BA%BF%E7%A8%8B%E6%B1%A0/:2:0","tags":["线程池"],"title":"线程池","uri":"/posts/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"},{"categories":["java"],"content":"你用这种方式跟面试官讲springMVC，让面试官高看你一眼 SpringMVC 之前是以servlet的方式去处理http请求 springmvc简化servlet的操作 现在前后端分离已经省去了模板渲染，Handler处理完就将数据转化json SpringMVC执行流程: 用户发送请求至前端控制器DispatcherServlet DispatcherServlet收到请求调用处理器映射器HandlerMapping。 处理器映射器根据请求url找到具体的处理器，生成处理器执行链HandlerExecutionChain(包括处理器对象和处理器拦截器)一并返回给DispatcherServlet。 DispatcherServlet根据处理器Handler获取处理器适配器HandlerAdapter执行HandlerAdapter处理一系列的操作，如：参数封装，数据格式转换，数据验证等操作 执行处理器Handler(Controller，也叫页面控制器)。 Handler执行完成返回ModelAndView HandlerAdapter将Handler执行结果ModelAndView返回到DispatcherServlet DispatcherServlet将ModelAndView传给ViewReslover视图解析器 ViewReslover解析后返回具体View DispatcherServlet对View进行渲染视图（即将模型数据model填充至视图中）。 DispatcherServlet响应用户。 ","date":"2022-02-12","objectID":"/posts/springmvc/:0:0","tags":["springMVC","spring"],"title":"SpringMvc","uri":"/posts/springmvc/"},{"categories":["数据库"],"content":"redis持久化，淘汰策略 Redis中级篇 以下为Redis 6.2.0 版本 ","date":"2022-02-11","objectID":"/posts/redis%E4%B8%AD%E7%BA%A7%E7%AF%87/:0:0","tags":["redis"],"title":"Redis中级篇","uri":"/posts/redis%E4%B8%AD%E7%BA%A7%E7%AF%87/"},{"categories":["数据库"],"content":"内存淘汰机制 Redis 提供 6 种数据淘汰策略： volatile-lru（least recently used）：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰 volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰 volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰 allkeys-lru（least recently used）：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的） allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰 noeviction （默认）：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！ 4.0 版本后增加以下两种： volatile-lfu（least frequently used）：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰 allkeys-lfu（least frequently used）：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key redis.conf配置文件设置内存淘汰策略 ： # 内存淘汰策略设置 maxmemory-policy allkeys-lru # redis内存大小设置（5Gb根据自己服务器内存来设置） maxmemory 5368709120 配置 Redis 内存大小 我们应该为 Redis 设置多大的内存容量呢？ 根据“八二原理“，即 80% 的请求访问了 20% 的数据，因此如果按照这个原理来配置，将 Redis 内存大小设置为数据总量的 20%，就有可能拦截到 80% 的请求。当然，只是有可能，对于不同的业务场景需要进行不同的配置，一般建议把缓存容量设置为总数据量的 15% 到 30%，兼顾访问性能和内存空间开销。 命令行： config set maxmemory 5gb #设置内存大小 config get maxmemory #查看 maxmemory 命令 PS: LRU 全称是 Least Recently Used，即最近最少使用，会将最不常用的数据筛选出来，保留最近频繁使用的数据。 LRU 会把所有数据组成一个链表，链表头部称为 MRU，代表最近最常使用的数据；尾部称为 LRU代表最近最不常使用的数据； LFU 全称 Least Frequently Used，即最不经常使用策略，它是基于数据访问次数来淘汰数据的，在 Redis 4.0 时添加进来。它在 LRU 策略基础上，为每个数据增加了一个计数器，来统计这个数据的访问次数。 LRU 算法在实现过程中使用链表管理所有缓存的数据，这会给 Redis 带来额外的开销，而且，当有数据访问时就会有链表移动操作，进而降低 Redis 的性能。 于是，Redis 对 LRU 的实现进行了一些改变： 记录每个 key 最近一次被访问的时间戳（由键值对数据结构 RedisObject 中的 lru 字段记录） 在第一次淘汰数据时，会先随机选择 N 个数据作为一个候选集合，然后淘汰 lru 值最小的。（N 可以通过 config set maxmemory-samples 100 命令来配置） 后续再淘汰数据时，会挑选数据进入候选集合，进入集合的条件是：它的 lru 小于候选集合中最小的 lru。 如果候选集合中数据个数达到了 maxmemory-samples，Redis 就会将 lru 值小的数据淘汰出去。 4、LFU 算法 LFU 全称 Least Frequently Used，即最不经常使用策略，它是基于数据访问次数来淘汰数据的，在 Redis 4.0 时添加进来。它在 LRU 策略基础上，为每个数据增加了一个计数器，来统计这个数据的访问次数。 前面说到，LRU 使用了 RedisObject 中的 lru 字段记录时间戳，lru 是 24bit 的，LFU 将 lru 拆分为两部分： ldt 值：lru 字段的前 16bit，表示数据的访问时间戳 counter 值：lru 字段的后 8bit，表示数据的访问次数 使用 LFU 策略淘汰缓存时，会把访问次数最低的数据淘汰，如果访问次数相同，再根据访问的时间，将访问时间戳最小的淘汰。 ","date":"2022-02-11","objectID":"/posts/redis%E4%B8%AD%E7%BA%A7%E7%AF%87/:1:0","tags":["redis"],"title":"Redis中级篇","uri":"/posts/redis%E4%B8%AD%E7%BA%A7%E7%AF%87/"},{"categories":["数据库"],"content":"持久化机制 RDB（默认采用） AOF （snapshotting，RDB）快照 Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。 RDB配置：（在本地redis目录下的redis.conf文件中修改） save 60 1 #在60秒(1分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。 save 360 6 #在360秒(6分钟)之后，如果至少有6个key发生变化，Redis就会自动触发BGSAVE命令创建快照。 （append-only file，AOF）追加文件 每有执行一条会更改Redis数据的命令，该命令写入到内存缓存 server.aof_buf 中，然后再根据 appendfsync 配置来决定何时将其同步到硬盘中的 AOF 文件。 AOF配置：（在本地redis目录下的redis.conf文件中修改） #AOF开启 appendonly yes #AOF 持久化方式 appendfsync always #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度 appendfsync everysec #每秒钟同步一次，显示地将多个写命令同步到硬盘(推荐) appendfsync no #让操作系统决定何时进行同步 ","date":"2022-02-11","objectID":"/posts/redis%E4%B8%AD%E7%BA%A7%E7%AF%87/:2:0","tags":["redis"],"title":"Redis中级篇","uri":"/posts/redis%E4%B8%AD%E7%BA%A7%E7%AF%87/"},{"categories":["数据库"],"content":"redis应用场景： set应用场景 关注模型（set交集并集差集） 电商商品筛选 抽奖需求：参与抽奖 、 查看所有抽奖者 、 开奖 参与抽奖： sadd key {userID} 查看所有抽奖者 ：smembers key 开奖： srandmember key [count] 集合中所有元素不变 / spop key [count] 抽中的元素会从元素中移除 ","date":"2022-02-11","objectID":"/posts/redis%E4%B8%AD%E7%BA%A7%E7%AF%87/:3:0","tags":["redis"],"title":"Redis中级篇","uri":"/posts/redis%E4%B8%AD%E7%BA%A7%E7%AF%87/"},{"categories":["定时任务"],"content":"对hashmap的认识有多少点进来看看吧 quartz ","date":"2022-02-10","objectID":"/posts/quartz/:0:0","tags":["quratz"],"title":"Quartz","uri":"/posts/quartz/"},{"categories":["定时任务"],"content":"Quartz API Quartz API的关键接口是： Scheduler - 与调度程序交互的主要API。 Job - 你想要调度器执行的任务组件需要实现的接口 JobDetail - 用于定义作业的实例。 Trigger（即触发器） - 定义执行给定作业的计划的组件。 JobBuilder - 用于定义/构建 JobDetail 实例，用于定义作业的实例。 TriggerBuilder - 用于定义/构建触发器实例。 Scheduler 的生命期，从 SchedulerFactory 创建它时开始，到 Scheduler 调用shutdown() 方法时结束；Scheduler 被创建后，可以增加、删除和列举 Job 和 Trigger，以及执行其它与调度相关的操作（如暂停 Trigger）。但是，Scheduler 只有在调用 start() 方法后，才会真正地触发 trigger（即执行 job） 导入包 \u003cparent\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-parent\u003c/artifactId\u003e \u003cversion\u003e2.4.1\u003c/version\u003e \u003crelativePath/\u003e \u003c!-- lookup parent from repository --\u003e \u003c/parent\u003e \u003c!--定时任务依赖--\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-quartz\u003c/artifactId\u003e \u003c/dependency\u003e \u003c/dependencies\u003e 设计模式： builder factory 组件模式 主要模块： jobDetail trigger schedule trigger:quartz中的触发器用来告诉调度程序作业什么时候触发，trigger用来触发执行job的 通用属性： jobkey startTime startAt endTime endAt simpleTrigger：在一个指定时间段内执行一次作业任务，或者在指定的时间间隔内多次执行作业任务 需要注意： 重复次数可以为0、正整数和REPEAT_INDEFINITELY（-1） 重复执行时间间隔必须为0或长整型 一定指定了endTime参数，那么它会覆盖重复次数参数的效果 job\u0026jobDetail 生命周期：任务调度器执行job 创建 用完就销毁 jobDetail ：job实例提供很多设置属性，以及JobDataMap成员变量 public class QuartzDemo { public static void main(String[] args) throws SchedulerException { HashMap\u003cString, String\u003e stringStringHashMap = new HashMap\u003c\u003e(); stringStringHashMap.put(\"spc\", \"hello quartz\"); JobDetail jobDetail = JobBuilder.newJob(HelloJob.class) .withIdentity(\"jobKey\") .usingJobData(new JobDataMap(stringStringHashMap)) .build(); System.out.println(jobDetail.getDescription()); System.out.println(jobDetail.getKey().getName()); System.out.println(jobDetail.getKey().getGroup()); System.out.println(jobDetail.getJobClass().getName()); SimpleTrigger trigger = TriggerBuilder.newTrigger() .withIdentity(\"triggerKey\", \"trigger\") .startNow() .withSchedule( SimpleScheduleBuilder .simpleSchedule() .withIntervalInMilliseconds(0) .withIntervalInSeconds(5) .repeatForever() ).build(); StdSchedulerFactory sfact = new StdSchedulerFactory(); Scheduler scheduler = sfact.getScheduler(); scheduler.start(); scheduler.scheduleJob(jobDetail, trigger); } public class HelloJob implements Job { private String SPC; public String getSPC() { return SPC; } public void setSPC(String SPC) { this.SPC = SPC; } @Override public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException { Date data = new Date(); SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-HH-dd HH:mm:ss\"); System.out.println(simpleDateFormat.format(data)); System.out.println(\"hello world\"); // JobDataMap mergedJobDataMap = jobExecutionContext.getMergedJobDataMap(); //你可以用jobExecutionContext.getMergedJobDataMap()来获取jobDetail的值 //也可以在继承job的子类上定义同名的属性get set方法（不分大小写）就能自动获取到属性值 System.out.println(\"spc value: \"+ SPC); } } 创建 jobBuilder-\u003e 创建 JobDetail TriggerBuilder-\u003eTrigger 当触发器被触发的时候会 重新job scheduler job （job，trigger）绑定在一起的 添加 scheduleJob 更新 rescheduleJob 删除 deleteJob 暂停 pauseJob 恢复 resumeJob 马上执行 triggerJob ….. 自身 开启 start 关闭 shutdown ….. 例子: public static void createScheduleJob(Scheduler scheduler, QuartzBean quartzBean) { try { //获取到定时任务的执行类 必须是类的绝对路径名称 //定时任务类需要是job类的具体实现 QuartzJobBean是job的抽象类。 Class\u003c? extends Job\u003e jobClass = (Class\u003c? extends Job\u003e) Class.forName(quartzBean.getJobClass()); // 构建定时任务信息 JobDetail jobDetail = JobBuilder.newJob(jobClass).withIdentity(quartzBean.getJobName()).build(); // 设置定时任务执行方式 CronScheduleBuilder scheduleBuilder = CronScheduleBuilder.cronSchedule(quartzBean.getCronExpression()); // 构建触发器trigger 日历的概念 CronTrigger trigger = newTrigger().withIdentity(quartzBean.getJobName()).withSchedule(scheduleBuilder).build(); scheduler.scheduleJob(jobDetail, trigger); } catch (ClassNotFoundException e) { System.out.println(\"定时任务类路径出错：请输入类的绝对路径\"); } catch (SchedulerException e) { System.out.println(\"创建定时任务出错：\" + e.getMessage()); } } job抽象类QuartzJobBean QuartzJobBean类中execute方法会调用executeInternal方法 public class MyTask1 extends QuartzJobBean { @Override protected void executeInternal(JobExecut","date":"2022-02-10","objectID":"/posts/quartz/:1:0","tags":["quratz"],"title":"Quartz","uri":"/posts/quartz/"},{"categories":["定时任务"],"content":"域取值 下表为Cron表达式中六个域能够取的值以及支持的特殊字符。（或者7个 第七个是年份） 域 是否必需 取值范围 特殊字符 秒 是 [0, 59] * , - / 分钟 是 [0, 59] * , - / 小时 是 [0, 23] * , - / 日期 是 [1, 31] * , - / ? L W 月份 是 [1, 12]或[JAN, DEC] * , - / 星期 是 [1, 7]或[MON, SUN]。若您使用[1, 7]表达方式，1代表星期一，7代表星期日。 * , - / ? L # 还有一个可不填的 年份 ","date":"2022-02-10","objectID":"/posts/quartz/:2:0","tags":["quratz"],"title":"Quartz","uri":"/posts/quartz/"},{"categories":["定时任务"],"content":"特殊字符 Cron表达式中的每个域都支持一定数量的特殊字符，每个特殊字符有其特殊含义。 特殊字符 含义 示例 * 所有可能的值。 在月域中，*表示每个月；在星期域中，*表示星期的每一天。 , 列出枚举值。 在分钟域中，5,20表示分别在5分钟和20分钟触发一次。 - 范围。 在分钟域中，5-20表示从5分钟到20分钟之间每隔一分钟触发一次。 / 指定数值的增量。 在分钟域中，0/15表示从第0分钟开始，每15分钟。在分钟域中3/20表示从第3分钟开始，每20分钟。 ? 不指定值，仅日期和星期域支持该字符。 当日期或星期域其中之一被指定了值以后，为了避免冲突，需要将另一个域的值设为?。 L 单词Last的首字母，表示最后一天，仅日期和星期域支持该字符。说明 指定 L字符时，避免指定列表或者范围，否则，会导致逻辑问题。 在日期域中，L表示某个月的最后一天。在星期域中，L表示一个星期的最后一天，也就是星期日（SUN）。如果在L前有具体的内容，例如，在星期域中的6L表示这个月的最后一个星期六。 W 除周末以外的有效工作日，在离指定日期的最近的有效工作日触发事件。W字符寻找最近有效工作日时不会跨过当前月份，连用字符LW时表示为指定月份的最后一个工作日。 在日期域中5W，如果5日是星期六，则将在最近的工作日星期五，即4日触发。如果5日是星期天，则将在最近的工作日星期一，即6日触发；如果5日在星期一到星期五中的一天，则就在5日触发。 # 确定每个月第几个星期几，仅星期域支持该字符。 在星期域中，4#2表示某月的第二个星期四。 JobExecutionContext 的参数在那里传 Quartz定时任务Job中无法注入spring bean的解决方案 使用spring 结合quartz进行定时任务开发时，如果直接在job内的execute方法内使用service 或者mapper对象，执行时，出现空指针异常。 ","date":"2022-02-10","objectID":"/posts/quartz/:3:0","tags":["quratz"],"title":"Quartz","uri":"/posts/quartz/"},{"categories":["定时任务"],"content":"问题原因 job对象在spring容器加载时候，能够注入bean，但是调度时，job对象会重新创建，此时就是导致已经注入的对象丢失，因此报空指针异常。 @Configuration public class TaskSchedulerConfig implements ApplicationListener\u003cContextRefreshedEvent\u003e { @Override public void onApplicationEvent(ContextRefreshedEvent event) { System.out.println(\"任务已经启动...\" + event.getSource()); } @Component(\"quartzJobFactory\") private class QuartzJobFactory extends AdaptableJobFactory { //这个对象Spring会帮我们自动注入进来,也属于Spring技术范畴. @Autowired private AutowireCapableBeanFactory capableBeanFactory; protected Object createJobInstance(TriggerFiredBundle bundle) throws Exception { //调用父类的方法 Object jobInstance = super.createJobInstance(bundle); //进行注入,这属于Spring的技术,不清楚的可以查看Spring的API. capableBeanFactory.autowireBean(jobInstance); return jobInstance; } } @Bean(name = \"scheduler\") public Scheduler scheduler(QuartzJobFactory quartzJobFactory) throws Exception { SchedulerFactoryBean factoryBean = new SchedulerFactoryBean(); factoryBean.setJobFactory(quartzJobFactory); factoryBean.afterPropertiesSet(); Scheduler scheduler = factoryBean.getScheduler(); scheduler.start(); return scheduler; } @Bean public QuartzInitializerListener executorListener() { return new QuartzInitializerListener(); } quartz job 异常处理 2种处理方式： 1.捕获并解决异常，立即重新执行作业 2.捕获异常，取消所有触发器 为了共享在同一个 JobDetail 中的 JobDataMap，我们需要在上面这个 job 实现类上加入 @PersistJobDataAfterExecution 和 @DisallowConcurrentExecution 注解，详见 Quartz 2 定时任务（二）：多线程并发执行与数据共享。 @PersistJobDataAfterExecution @DisallowConcurrentExecution public class BadJob1 implements Job { @Override public void execute(JobExecutionContext context) throws JobExecutionException { SimpleDateFormat dateFormat = new SimpleDateFormat( \"yyyy-MM-dd HH:mm:ss\"); JobKey jobKey = context.getJobDetail().getKey(); JobDataMap dataMap = context.getJobDetail().getJobDataMap(); int flag = dataMap.getInt(\"flag\"); System.out.println(\"---\" + jobKey + \"，执行时间：\" + dateFormat.format(new Date()) + \", flag： \" + flag); // 由于零错误除以此作业将生成的异常的例外（仅在第一次运行） try { int result = 4815 / flag; } catch (Exception e) { System.out.println(\"--- Job1 出错!\"); // 修复分母，所以下次这个作业运行它不会再失败 JobExecutionException e2 = new JobExecutionException(e); dataMap.put(\"flag\", \"1\"); //方法一 这个工作会立即重新启动（不能与方法二同时使用） e2.setRefireImmediately(true); //方法二 true 表示 Quartz 会自动取消所有与这个 job 有关的 trigger，从而避免再次运行 job e2.setUnscheduleAllTriggers(true); throw e2; } System.out.println(\"---\" + jobKey + \"，完成时间：\" + dateFormat.format(new Date())); } } ","date":"2022-02-10","objectID":"/posts/quartz/:3:1","tags":["quratz"],"title":"Quartz","uri":"/posts/quartz/"},{"categories":["ORM"],"content":"spring data jpa 中的hibernate也有他的优点，那jpa和mybaits谁更胜一筹？ Spring data jpa spring data jpa的官网：spring data Jpa ","date":"2022-02-10","objectID":"/posts/spring-data-jpa/:0:0","tags":["jpa","hibernate","ORM"],"title":"Spring Data Jpa","uri":"/posts/spring-data-jpa/"},{"categories":["ORM"],"content":"简介 spring默认使用是hibernate orm框架，全自动orm能帮你不用写任何一条sql语句，在服务端和数据库之前增加一层新的。从而使人可以更加关注代码逻辑。 优点是直接关注对象，创建表和查询语句都能jpa帮你自动生成 缺点也是很明显，复杂的sql，更新要传递整个实体对象 怎么用？ 高级的用法（扩展包Fenix https://github.com/blinkfox/fenix）？ 比较常见的错误？ 读写锁 @Lock(LockModeType.PESSIMISTIC_WRITE) 读写锁sql方法上 只能在select上用？？ 如果是@NameQuery，则可以 @NamedQuery(name=\"lockArticle\",query=\"select a from Article a where a.id = :id\",lockMode = PESSIMISTIC_READ) public class Article 如果用entityManager的方式，则可以设置LocakMode： Query query = entityManager.createQuery(\"from Article where articleId = :id\"); query.setParameter(\"id\", id); query.setLockMode(LockModeType.PESSIMISTIC_WRITE); query.getResultList(); entityManager.find(Department.class, 1, LockModeType.PESSIMISTIC_READ); @Transient Specifies that the property or field is not persistent. It is used * to annotate a property or field of an entity class, mapped * superclass, or embeddable class. @Modifying @Repository HQL 原生sql @Query(nativeQuery = true,value=\"sql 语句\" 您可以使用构造函数表达式JPQL查询，您的查询如下所示： select new StatsDTO(count(u),u.typeId,u.modifiedAt) from UserCampaignObjective u where campId = ? group by objectiveTypeId,modifiedAt 用原生的话 属性名要改对应的 public interface StatsBo { Integer getUserCount(); Byte getTypeId(); Instant getModifiedAt(); } //CrudRepository 不是StatsBo 返回值要StatsBo可以通过这种方式 public interface UserRepository extends CrudRepository\u003cStatsBean, Long\u003e { @Query(value = \"select count(type_id) userCount, type_id as typeId, modified_at as modifiedAt from ...\", nativeQuery = true) List\u003cStatsDTO\u003e getStatsDTO(Long camp_id); } jpa问题 sql 用别名 分页出现问题 因为是分页查询，当然需要知道数据的总数，所以hibernate会自动的执行sql帮你查询所有的数量，但是看下图就能发现，他把我的表名的别名当做字段来select count 了。 1.unknown column ‘xxx’ in ‘field list’ 这明显说明有sql把你这个xxx当做字段了，而我这个是表名的别名，这样就能定位到sql错误 解决办法：写countQuery @Query(nativeQuery = true, countQuery =\"select count(*) from (\"+conferenceRoomBoQuery+\") m\", value = conferenceRoomBoQuery) ","date":"2022-02-10","objectID":"/posts/spring-data-jpa/:1:0","tags":["jpa","hibernate","ORM"],"title":"Spring Data Jpa","uri":"/posts/spring-data-jpa/"},{"categories":["ORM"],"content":"jpa问题 ","date":"2022-02-10","objectID":"/posts/spring-data-jpa/:2:0","tags":["jpa","hibernate","ORM"],"title":"Spring Data Jpa","uri":"/posts/spring-data-jpa/"},{"categories":["ORM"],"content":"update delete 需要spring事务注解 不然会报 @Modifying(clearAutomatically = true) javax.persistence.TransactionRequiredException: Executing an update/delete query 返回类型是 void int Modifying queries can only use void or int/Integer as return type! jpa 分页 新建对象，一个参数会报错 RegisterTimeBo(m)，一个以上就不会 RegisterTimeBo(m,u) Unexpected token count in with Pageable //不会报错 @Query(\"select new com.gonsin.venus.bo.meeting.RegisterTimeBo(m,u) \" + \"from RegisterTimeBean m \" + \"left join UserInfoBean u \" + \"on m.userInfoKey=u.keyOnly \" + \" where m.meetingKey=:meetingKey\") Page\u003cRegisterTimeBo\u003e findByMeetingKey(@Param(\"meetingKey\") String meetingKey, Pageable pageable); //会报错 @Query(\"select new com.gonsin.venus.bo.meeting.RegisterTimeBo(m) \" + \"from RegisterTimeBean m \" + \" where m.meetingKey=:meetingKey\") Page\u003cRegisterTimeBo\u003e findByMeetingKey(@Param(\"meetingKey\") String meetingKey, Pageable pageable); jpa问题： unable to obtain isolated JDBC sqlite 线程池最大连接设置为1（不管这个问题） 保存不到saveAndFlush 保存出问题会一直卡住才会这样 为什么保存会一直卡住 是因为id主键没有设置正确 @GeneratedValue(strategy = GenerationType.IDENTITY) //下面是 使用错误导致 GenericGenerator应该怎么用 // @GeneratedValue // @GenericGenerator(name = \"idgenerator\", strategy = \"identity\" ) 更新和删除再别的事务上 [Row was updated or deleted by another transaction (or unsaved-value mapping was incorrect) ] 主因 : 事务对程序的影响 原因一: 查询出来的对象和update的对象不是同一个 当前version版本与数据库中version版本不一致。 解决: 用查询出的对象进行set 值, 再用同一个对象update version为同一个就行了 原因二: 查询出来的对象在缓存中一段时间 , 之后再进行的update 解决: 把这个对象从缓存中剔除(如需要对象属性可先get保存到变量中) , 在update之之前再查询出来进行update 原因三: 同一对象查询了多次 , 数据还在缓存中没有清除. 解决: 清除缓存中的对象 @Modifying(clearAutomatically = true) ","date":"2022-02-10","objectID":"/posts/spring-data-jpa/:2:1","tags":["jpa","hibernate","ORM"],"title":"Spring Data Jpa","uri":"/posts/spring-data-jpa/"},{"categories":["ORM"],"content":"复杂查询 ","date":"2022-02-10","objectID":"/posts/spring-data-jpa/:3:0","tags":["jpa","hibernate","ORM"],"title":"Spring Data Jpa","uri":"/posts/spring-data-jpa/"},{"categories":["ORM"],"content":"条件查询 1.接口继承JpaSpecificationExecutor\u003cT\u003e @Repository public interface UserRepository extends JpaRepository\u003cInteger,User\u003e, JpaSpecificationExecutor\u003cUser\u003e { } 2.方法调用 @Service public class UserService { @Resource private UserRepository userRepository; public void test(SearchParam searchParam){ Specification\u003cDeviceBean\u003e spec = new Specification\u003cDeviceBean\u003e() { @Override public Predicate toPredicate(Root\u003cDeviceBean\u003e root, CriteriaQuery\u003c?\u003e query, CriteriaBuilder criteriaBuilder) { // root java实体类中的对象而不是 root.get是java实体类属性名而不是数据库中的字段名 Predicate delete = criteriaBuilder.equal(root.get(\"delete\"),false); if (StringUtils.isNotBlank(searchParam.getUsername())) { Path\u003cObject\u003e custId = root.get(\"deviceName\"); //当查询条件用到gt, ge, lt, le, like（分别表示\u003e, \u003e=, \u003c, \u003c=,模糊查询）时，需要表明查询对象属性的类别 Predicate like = criteriaBuilder.like(custId.as(String.class), \"%\" + searchParam.getUsername() + \"%\"); return criteriaBuilder.and(delete, like); } return delete; } }; List\u003cUser\u003e result = userRepository.findAll(spec); } } ","date":"2022-02-10","objectID":"/posts/spring-data-jpa/:3:1","tags":["jpa","hibernate","ORM"],"title":"Spring Data Jpa","uri":"/posts/spring-data-jpa/"},{"categories":["ORM"],"content":"排序分 Sort.Direction.DESC表示降序 Sort.Direction.ASC表示升序 Sort sort = new Sort(Sort.Direction.DESC, \"id\"); //sort作为findAll()方法中的参数，查询得到得到的结果是经过排序的 List\u003cMessage\u003e result = MessageRepository.findAll(sort); ","date":"2022-02-10","objectID":"/posts/spring-data-jpa/:3:2","tags":["jpa","hibernate","ORM"],"title":"Spring Data Jpa","uri":"/posts/spring-data-jpa/"},{"categories":["ORM"],"content":"页查询 //Page 类 //获取总页数 int getTotalPages(); //获取总记录数 long getTotalElements(); //获取列表数据 List\u003cT\u003e getContent(); //设置分页参数 Pageable pageable = PageRequest.of(0，5); //分页查询 Page\u003cMessage\u003e page = MessageRepository.findAll(pageable); ","date":"2022-02-10","objectID":"/posts/spring-data-jpa/:3:3","tags":["jpa","hibernate","ORM"],"title":"Spring Data Jpa","uri":"/posts/spring-data-jpa/"},{"categories":["java"],"content":"对hashmap的认识有多少点进来看看吧 HashMap ","date":"2022-02-09","objectID":"/posts/hashmap/:0:0","tags":["HashMap","数据结构","面试"],"title":"HashMap","uri":"/posts/hashmap/"},{"categories":["java"],"content":"底层数据结构： jdk1.7：数组+链表 链表是解决hash冲突 jdk1.8：数组+链表+红黑树 链表过长会影响性能 当链表超过 8 且数据总量超过 64 才会转红黑树。 将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树，以减少搜索时间。 ","date":"2022-02-09","objectID":"/posts/hashmap/:1:0","tags":["HashMap","数据结构","面试"],"title":"HashMap","uri":"/posts/hashmap/"},{"categories":["java"],"content":"HashMap 的扩容方式？ Hashmap 在容量超过负载因子所定义的容量之后，就会扩容。Java 里的数组是无法自动扩容的，方法是将 Hashmap 的大小扩大为原来数组的两倍，并将原来的对象放入新的数组中。jdk1.7使用头插法 jdk1.8使用尾插法 ","date":"2022-02-09","objectID":"/posts/hashmap/:2:0","tags":["HashMap","数据结构","面试"],"title":"HashMap","uri":"/posts/hashmap/"},{"categories":["java"],"content":"链表长度为8，为什么选择8 ？（泊松分布） HashMap源码中，容器中节点分布在 hash 桶中的频率遵循**泊松分布**，按照泊松分布的计算公式计算出了桶中元素个数和概率的对照表，可以看到链表中元素个数为 8 时的概率已经非常小，再多的就更少了，所以原作者在选择链表元素个数时选择了 8，是根据概率统计而选择的。 默认加载因子是多少？为什么是 0.75 ？ 默认的loadFactor是0.75，0.75是对空间和时间效率的一个平衡选择，一般不要修改，除非在时间和空间比较特殊的情况下 ： 如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值 。 相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。 ","date":"2022-02-09","objectID":"/posts/hashmap/:3:0","tags":["HashMap","数据结构","面试"],"title":"HashMap","uri":"/posts/hashmap/"},{"categories":["java"],"content":"hashmap 和 hashtable 区别？ 线程安全问题： hashtable的方法是同步，hashmap中的方法是非同步， **继承关系：**HashTable是基于陈旧的Dictionary类继承来的。 HashMap继承的抽象类AbstractMap实现了Map接口。 允不允许null值： HashTable中，key和value都不允许出现null值，否则会抛出NullPointerException异常。 HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。 默认初始容量和扩容机制： HashTable中的hash数组初始大小是11，增加的方式是 old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。 哈希值的使用不同 ： HashTable直接使用对象的hashCode。 HashMap重新计算hash值。 遍历方式的内部实现上不同 ： Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。 HashMap 实现 Iterator，支持fast-fail，Hashtable的 Iterator 遍历支持fast-fail，用 Enumeration 不支持 fast-fail ","date":"2022-02-09","objectID":"/posts/hashmap/:4:0","tags":["HashMap","数据结构","面试"],"title":"HashMap","uri":"/posts/hashmap/"},{"categories":["MySQL"],"content":"mysql索引失效 MySql索引失效 ","date":"2022-02-09","objectID":"/posts/mysql%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/:0:0","tags":["mysql索引","索引","面试"],"title":"Mysql索引失效","uri":"/posts/mysql%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/"},{"categories":["MySQL"],"content":"索引失效10种场景 具体文章：聊聊索引失效的10种场景，太坑了 select * like % 使用 or 不满足最左匹配原则 索引列上使用函数 索引列上使用计算 字段类型不同 例如：int varchar 索引int = varchar 会隐式转换 列对比 not in 和 not exists order by的坑 如果使用了or关键字，那么它前面和后面的字段都要加索引，不然所有的索引都会失效，这是一个大坑。 在 MySQL 中应该对 in / not in查询的字节长度是有限制的。 当超过了长度（不确定）就不在走索引 in/ not in https://segmentfault.com/a/1190000023825926 not exists t1 表哪种情况都不会走索引，而 t2 表是有索引的情况下就会走索引。为什么会出现这种情况？ ","date":"2022-02-09","objectID":"/posts/mysql%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/:1:0","tags":["mysql索引","索引","面试"],"title":"Mysql索引失效","uri":"/posts/mysql%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/"},{"categories":["MySQL"],"content":"in和exists的执行流程 对于 in 查询来说，会先执行子查询，如上边的 t2 表，然后把查询得到的结果和外表 t1 做笛卡尔积，再通过条件进行筛选（这里的条件就是指 name 是否相等），把每个符合条件的数据都加入到结果集中。 对于 exists 来说，是先查询遍历外表 t1 ，然后每次遍历时，再检查在内表是否符合匹配条件，即检查是否存在 name 相等的数据。 ","date":"2022-02-09","objectID":"/posts/mysql%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/:2:0","tags":["mysql索引","索引","面试"],"title":"Mysql索引失效","uri":"/posts/mysql%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/"},{"categories":["设计模式"],"content":"23种设计模式 ","date":"2022-02-08","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:0:0","tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"一、设计模式的来源 设计模式（Design Pattern）是前辈们对代码开发经验的总结，是解决特定问题的一系列套路。它不是语法规定，而是一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案。 设计模式脑图 ","date":"2022-02-08","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"二、设计模式的六大原则（SOLID） 总原则——开闭原则（Open Closed Principle） 一个软件实体，如类、模块和函数应该对扩展开放，对修改关闭。 在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。 想要达到这样的效果，我们需要使用接口和抽象类等。 1、单一职责原则（Single Responsibility Principle） 一个类应该只有一个发生变化的原因。 不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，否则就应该把类拆分。 2、里氏替换原则（Liskov Substitution Principle） 所有引用基类的地方必须能透明地使用其子类的对象。 任何基类可以出现的地方，子类一定可以出现。里氏替换原则是继承复用的基石，只有当衍生类可以替换基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。 里氏代换原则是对“开-闭”原则的补充。实现“开闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏替换原则是对实现抽象化的具体步骤的规范。里氏替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。 3、依赖倒置原则（Dependence Inversion Principle） 1、上层模块不应该依赖底层模块，它们都应该依赖于抽象。 2、抽象不应该依赖于细节，细节应该依赖于抽象。 面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。 4、接口隔离原则（Interface Segregation Principle） 1、客户端不应该依赖它不需要的接口。 2、类间的依赖关系应该建立在最小的接口上。 每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。 5、迪米特法则（最少知道原则）(Law of Demeter) 只与你的直接朋友交谈，不跟“陌生人”说话。 一个类对自己依赖的类知道的越少越好。无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。 最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。 6、合成复用原则（Composite Reuse Principle） 尽量使用对象组合/聚合，而不是继承关系达到软件复用的目的。 合成或聚合可以将已有对象纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能。 记忆口诀：SOLID CD（稳固的CD）。 ","date":"2022-02-08","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"三、设计模式的三大类 创建型模式（Creational Pattern）：对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。 （5种）工厂模式、抽象工厂模式、单例模式、建造者模式、原型模式 记忆口诀：创工原单建抽（创公园，但见愁） 结构型模式（Structural Pattern）：关注于对象的组成以及对象之间的依赖关系，描述如何将类或者对象结合在一起形成更大的结构，就像搭积木，可以通过简单积木的组合形成复杂的、功能更为强大的结构。 （7种）适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式 记忆口诀：结享外组适代装桥（姐想外租，世代装桥） 行为型模式（Behavioral Pattern）：关注于对象的行为问题，是对在不同的对象之间划分责任和算法的抽象化；不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。 （11种）策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式 记忆口诀：行状责中模访解备观策命迭（形状折中模仿，戒备观测鸣笛） ","date":"2022-02-08","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:3:0","tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"四、23种设计模式 ","date":"2022-02-08","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:4:0","tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"———————创建型模式——————— ","date":"2022-02-08","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:5:0","tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"工厂模式 工厂模式（Factory Pattern）是Java中最常用的设计模式之一。 在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。 定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。 应用实例：您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。而至于需要哪个牌子的汽车，就到哪个牌子的工厂。 ","date":"2022-02-08","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:6:0","tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"抽象工厂模式 抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。 在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 应用实例：对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，都是成套的，即一系列具体产品。假设一种情况，在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OO 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。 ","date":"2022-02-08","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:7:0","tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"单例模式 单例模式（Singleton Pattern）是Java中最简单的设计模式之一。 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 保证一个类仅有一个实例，并提供一个访问它的全局访问点。 应用实例：一个班级只能有一个班主任。 ","date":"2022-02-08","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:8:0","tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"建造者模式（构建者模式） 建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。 一个Builder类会一步一步构造最终的对象。该Builder类是独立于其他对象的。 将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。 应用实例： 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的“套餐”； 2、Java 中的 StringBuilder。 ","date":"2022-02-08","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:9:0","tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"原型模式 原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。 这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 应用实例： 1、细胞分裂； 2、Java中的 Object clone() 方法。 ","date":"2022-02-08","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:10:0","tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"———————结构型模式——————— ","date":"2022-02-08","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:11:0","tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"适配器模式 适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。 这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。 将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 应用实例： 1、读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡； 2、美国电器110V，中国220V，就要有一个变压器将110V转化为220V。 ","date":"2022-02-08","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:12:0","tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"装饰器模式 装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。 这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。 动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。 应用实例： 1、孙悟空有72变，当他变成\"庙宇\"后，他的根本还是一只猴子，但是他又有了庙宇的功能； 2、将一个形状装饰上不同的颜色，同时又不改变形状。 ","date":"2022-02-08","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:13:0","tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"代理模式 在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。 在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。 为其他对象提供一种代理以控制对这个对象的访问。 应用实例： 1、Windows里面的快捷方式； 2、买火车票不一定在火车站买，也可以去代售点； 3、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制； 4、Spring AOP。 注意事项： 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。 ","date":"2022-02-08","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:14:0","tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"外观模式 外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。 这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。 为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 应用实例： 去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。 ","date":"2022-02-08","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:15:0","tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"桥接模式 桥接模式（Bridge Pattern）是用于把抽象化与实现化解耦，使得二者可以独立变化。它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。 这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。 将抽象部分与实现部分分离，使它们都可以独立的变化。 又称为柄体（Handle and Body）模式或接口（Interface）模式。 应用实例： 1、猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择； 2、墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的； 3、如果要绘制不同的颜色，如红色、绿色、蓝色的矩形、圆形、椭圆、正方形，我们需要根据实际需要对形状和颜色进行组合，那么颜色、形状就是抽象部分，组合后的就是实现部分。 注意事项：对于两个独立变化的维度，使用桥接模式再适合不过了。 ","date":"2022-02-08","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:16:0","tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"组合模式 组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。 这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。 将对象组合成树形结构以表示\"部分-整体\"的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。 应用实例： 1、算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作数也可以是操作数、操作符和另一个操作数。 2、在JAVAAWT和SWING中，对于Button和Checkbox是树叶，Container是树枝。 ","date":"2022-02-08","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:17:0","tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"享元模式 享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。 享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。 运用共享技术有效地支持大量细粒度的对象。 应用实例： 1、Java中的String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面； 2、数据库的数据池。 ","date":"2022-02-08","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:18:0","tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"———————行为型模式——————— ","date":"2022-02-08","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:19:0","tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"策略模式 在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。 在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的context对象。策略对象改变context对象的执行算法。 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。 应用实例： 1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略； 2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 ","date":"2022-02-08","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:20:0","tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模板模式 在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 应用实例： 1、在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异； 2、西游记里面菩萨定好的81难，这就是一个顶层的逻辑骨架； 3、spring中对Hibernate的支持，将一些已经定好的方法封装起来，比如开启事务、获取Session、关闭Session等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。 ","date":"2022-02-08","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:21:0","tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"观察者模式 当对象间存在一对多关系时，则使用观察者模式（ObserverPattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。 应用实例： 1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价； 2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。 ","date":"2022-02-08","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:22:0","tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"迭代器模式 迭代器模式（Iterator Pattern）是Java和.Net编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。 迭代器模式属于行为型模式。 提供一种方法顺序访问一个聚合对象中各个元素，而又无须暴露该对象的内部表示。 应用实例：JAVA中的iterator。 ","date":"2022-02-08","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:23:0","tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"责任链模式 顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。 在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。 避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。 应用实例：红楼梦中的\"击鼓传花\"。 ","date":"2022-02-08","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:24:0","tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"命令模式 命令模式（Command Pattern）是一种数据驱动的设计模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。 将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。 应用实例：电视机是请求的接收者，遥控器是请求的发送者，遥控器上有一些按钮，不同的按钮对应电视机的不同操作。抽象命令角色由一个命令接口来扮演，有三个具体的命令类实现了抽象命令接口，这三个具体命令类分别代表三种操作：打开电视机、关闭电视机和切换频道。 ","date":"2022-02-08","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:25:0","tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"备忘录模式 备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。 应用实例： 1、后悔药； 2、打游戏时的存档； 3、Windows里的ctri+z； 4、IE中的后退； 5、数据库的事务管理。 ","date":"2022-02-08","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:26:0","tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"状态模式 在状态模式（State Pattern）中，类的行为是基于它的状态改变的。 在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的context对象。 允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。 应用实例： 1、打篮球的时候运动员可以有正常状态、不正常状态和超常状态； 2、曾侯乙编钟中，‘钟是抽象接口’，‘钟A’等是具体状态，‘曾侯乙编钟’是具体环境（Context）。 ","date":"2022-02-08","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:27:0","tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"访问者模式 在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。 主要将数据结构与数据操作分离。 主要解决：稳定的数据结构和易变的操作耦合问题。 应用实例：您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式。 ","date":"2022-02-08","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:28:0","tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"中介者模式 中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。 用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 应用实例： 1、中国加入WTO之前是各个国家相互贸易，结构复杂，现在是各个国家通过WTO来互相贸易； 2、机场调度系统； 3、MVC框架，其中C（控制器）就是M（模型）和V（视图）的中介者。 ","date":"2022-02-08","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:29:0","tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"解释器模式 解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在SQL解析、符号处理引擎等。 给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。 应用实例：编译器、运算表达式计算。 ","date":"2022-02-08","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:30:0","tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["java"],"content":"spring流程 xml，注解Annotation，配置类，等等 有一个抽象层来的读取bean（BeanDefinitionReader） beanfactoryPostProcessor来扩展bean 得到bean的信息 反射来创建实例和BeanPostProcessor来扩展 监听器：如果在容器的不同阶段做不同的事情，那么怎么来处理？ BeanFactory：按照模板来创建bean FactoryBean：创建独特bean ","date":"2020-07-23","objectID":"/posts/spring%E6%B5%81%E7%A8%8B/:0:0","tags":["spring"],"title":"Spring流程","uri":"/posts/spring%E6%B5%81%E7%A8%8B/"},{"categories":["Java"],"content":"深入了解JVM • JVM是这个星球上最强⼤的VM • Groovy/Scala/Kotlin/Jython/JRuby 栈、堆、本地方法栈、方法区、程序计数器 栈帧 • 局部变量表 • 操作数栈 ⽅法区 • 被整个虚拟机所共享的Class信息 • 运⾏时常量池 • Java7之前：永久代（PermGen） • OutOfMemory: Perm gen • Java8之后：元空间（Metaspace） • 元空间和Native共享内存 为什么要改，之前是和堆放在一起，容易OutofMemory JustInTime Compiler JLS与JVMS • Java语⾔规范 Java Language Specification • 定义Java语⾔的语法 • Java虚拟机规范 JVM Specification • 定义字节码如何在JVM中运⾏ 是不是所有的对象和数组都会在堆内存分配空间 在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。 ","date":"2020-07-15","objectID":"/posts/jvm/:0:0","tags":["jvm"],"title":"JVM","uri":"/posts/jvm/"},{"categories":["java"],"content":"解放你的双手，省去重复劳动 持续化集成和自动化测试 ","date":"2020-04-16","objectID":"/posts/%E6%8C%81%E7%BB%AD%E5%8C%96%E9%9B%86%E6%88%90-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/:0:0","tags":["CI","automated test"],"title":"持续化集成 自动化测试","uri":"/posts/%E6%8C%81%E7%BB%AD%E5%8C%96%E9%9B%86%E6%88%90-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"},{"categories":["java"],"content":"自动化测试 黑盒测试，白盒测试，冒烟测试 单元测试(unit test) 快，方便，但不可用 集成测试(integration test) 慢，复杂，安全可靠 回归测试(regression) java 中测试框架 JUnit4 JUnit5 TestNG ··· 持续化集成 线上的，对于开源项目免费 travisci circleci appveyor … 本地大名鼎鼎的Jenkins ","date":"2020-04-16","objectID":"/posts/%E6%8C%81%E7%BB%AD%E5%8C%96%E9%9B%86%E6%88%90-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/:1:0","tags":["CI","automated test"],"title":"持续化集成 自动化测试","uri":"/posts/%E6%8C%81%E7%BB%AD%E5%8C%96%E9%9B%86%E6%88%90-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"},{"categories":["java"],"content":"why use regex? 正则表达式 ","date":"2020-03-15","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:0:0","tags":["regex"],"title":"正则表达式","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["java"],"content":"常用的单元字符 ^ $ . \\w \\s \\d \\b ","date":"2020-03-15","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:1:0","tags":["regex"],"title":"正则表达式","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["java"],"content":"重复 * + ? {n} {n,} {n,m} ","date":"2020-03-15","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:2:0","tags":["regex"],"title":"正则表达式","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["java"],"content":"选择 [aeiou] [0-9] [A-Z] {A-Z0-9] h|H 等价于 [hH] ","date":"2020-03-15","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:3:0","tags":["regex"],"title":"正则表达式","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["java"],"content":"反义 [^aeiou] [^A] \\W \\S \\D \\B 例子： (?m)^\\[.*?\\] java中的正则表达式 String split() replaceAll()/replaceFirst() matches() 尽量少用或者少编译，因为效率低 （看源代码就知道了） java中的正则表达式是比较昂贵的 正则表达式需要解析，代码非常昂贵 （解析过程非常复杂，看源代码Pattern） 匹配过程非常昂贵 （它匹配是方式是回溯法） 因此在写正则表达式中用常量编译一次就可以了 private static final Pattern name=Pattern.compile(“正则表达式”); 匹配 1.regexName.matcher(“文本”) \u003c———- return Object[]？？？ 2.String.replaceAll(regexName,“文本”)； 调用Pattern.compile(); regexName.matcher(“文本”); ","date":"2020-03-15","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:4:0","tags":["regex"],"title":"正则表达式","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["java"],"content":"分组和捕获 正则表达式匹配到返回Object[]？？？ Matcher matcher 第一个matcher.group(0)是整一个正则表达式 matcher.group(1)是第一个分组就是 () 分组的编号计算只看左括号 (?:)不捕获和分配编号，括号只用于分组或标记优先级 还有没有些 (?:)这样类型 例如 ?m ","date":"2020-03-15","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:5:0","tags":["regex"],"title":"正则表达式","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["java"],"content":"AOP?怎么用？与oop对比好处？如何代理，注解处理？ 不管是代理/注解/动态字节码增强 都是要处理原来class，创建新的class 方法拦截 AOP Aspect-Oriented Programming ⾯向切⾯编程 相对于OOP（⾯向对象编程） AOP是⾯向切⾯编程，关注⼀个统⼀的切⾯ 面向方法的切面来编程，而不是面向某一个方法调用来编程 AOP和Spring是不同的东⻄ ","date":"2020-03-08","objectID":"/posts/aop/:0:0","tags":["AOP","Spring"],"title":"AOP","uri":"/posts/aop/"},{"categories":["java"],"content":"AOP适合于哪些场景 需要统⼀处理的场景 ⽇志 缓存 鉴权 如果⽤OOP来做需要怎么办？ 装饰器模式/静态代理 代理模式主要是控制对某个特定对象访问，而装饰模式主要是为了给对象添加行为。 ","date":"2020-03-08","objectID":"/posts/aop/:1:0","tags":["AOP","Spring"],"title":"AOP","uri":"/posts/aop/"},{"categories":["java"],"content":"AOP的实现 JDK动态代理 优点：⽅便，不需要依赖任何第三⽅库 缺点：功能受限，只适⽤于接⼝ CGLIB/ByteBuddy字节码⽣成 优点：强⼤，不受接⼝的限制 缺点：需要引⽤额外的第三⽅类库 不能增强final类/final/private⽅法 //JDK动态代理 //1.interface、实现类、Proxy类 //2.Proxy.newProxyInstance //3.invoke //------------------------------- //1. public interface Server { int a(int i); int b(int i); } public class DataServer implements Server { @Override public int a(int i) {return i;} @Override public int b(int i) {return i;} public int c(int i){return i;} } import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; public class LogProxy implements InvocationHandler { //3.invoke写自己拦截后想做什么 @Override public Object invoke(Object o, Method method, Object[] objects) throws Throwable { if(method.getName().equals(\"a\")){ System.out.println(\"a invoke\"); return 1; } return null; } } //2. public class ProblemDemo { static DataServer server=new DataServer(); public static void main(String[] args) { System.out.println(server.getClass()); Server dataServer = (Server) Proxy.newProxyInstance(server.getClass().getClassLoader(), new Class[]{Server.class}, new LogProxy()); System.out.println(dataServer.a(1)); dataServer.b(1); System.out.println(dataServer.getClass()); } } //CGLIB (动态字节码增强) //maven 导包 //代理和被代理类 //Enhancer设置setSuperclass、setCallback import net.sf.cglib.proxy.Enhancer; import net.sf.cglib.proxy.MethodInterceptor; import net.sf.cglib.proxy.MethodProxy; import java.lang.reflect.Method; import java.lang.reflect.Proxy; import java.util.Arrays; public class ProblemDemo { static DataServer server=new DataServer(); //-----代理类----- public static class LogInterceptor implements MethodInterceptor{ private DataServer delegate; public LogInterceptor(DataServer delegate) { this.delegate = delegate; } public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable { System.out.println(method.getName()+\"is invoke \"+ Arrays.toString(objects)); Object retValue=method.invoke(delegate,objects); System.out.println(method.getName()+\"is finished \" +retValue); return retValue; } } public static void main(String[] args) { Enhancer enhancer=new Enhancer(); enhancer.setSuperclass(DataServer.class); enhancer.setCallback(new LogInterceptor(server)); DataServer dataServer= (DataServer) enhancer.create(); dataServer.a(1); dataServer.b(1); } } ","date":"2020-03-08","objectID":"/posts/aop/:2:0","tags":["AOP","Spring"],"title":"AOP","uri":"/posts/aop/"},{"categories":["java"],"content":"装饰器模式 Decorator pattern 动态地为⼀个对象增加功能，但是不改变其结构 本质上是⼀个“包装” ","date":"2020-03-08","objectID":"/posts/aop/:3:0","tags":["AOP","Spring"],"title":"AOP","uri":"/posts/aop/"},{"categories":["java"],"content":"AOP与Spring 在Spring中使⽤AOP实现Redis缓存 Spring是如何切换JDK动态代理和CGLIB的？ spring.aop.proxy-target-class=true @Aspect声明切⾯ @Before @After @Around ","date":"2020-03-08","objectID":"/posts/aop/:4:0","tags":["AOP","Spring"],"title":"AOP","uri":"/posts/aop/"},{"categories":["数据库"],"content":"why Redis? Redis ","date":"2020-03-08","objectID":"/posts/redis%E5%9F%BA%E7%A1%80%E7%AF%87/:0:0","tags":["redis"],"title":"Redis","uri":"/posts/redis%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["数据库"],"content":"什么是redis 是c语言写基于的数据库，redis中的数据是存储在内存中的，因此非常快。 ","date":"2020-03-08","objectID":"/posts/redis%E5%9F%BA%E7%A1%80%E7%AF%87/:1:0","tags":["redis"],"title":"Redis","uri":"/posts/redis%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["数据库"],"content":"为什么要选redis 分布式缓存的话，使用的比较多的主要是 Memcached 和 Redis 共同点 ： 都是基于内存的数据库，一般都用来当做缓存使用。 都有过期策略。 两者的性能都非常高。 区别 ： Redis 支持更丰富的数据类型（支持更复杂的应用场景）。Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k/v 数据类型。 Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memecache 把数据全部存在内存之中。 Redis 有灾难恢复机制。 因为可以把缓存中的数据持久化到磁盘上。 Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。 Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的。 Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。 （Redis 6.0 引入了多线程 IO ） Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言。 Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。 ","date":"2020-03-08","objectID":"/posts/redis%E5%9F%BA%E7%A1%80%E7%AF%87/:2:0","tags":["redis"],"title":"Redis","uri":"/posts/redis%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["数据库"],"content":"redis有什么作用 分布式锁 ： 通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。相关阅读：《分布式锁中的王者方案 - Redisson》。 限流 ：一般是通过 Redis + Lua 脚本的方式来实现限流。相关阅读：《我司用了 6 年的 Redis 分布式限流器，可以说是非常厉害了！》。 消息队列 ：Redis 自带的 list 数据结构可以作为一个简单的队列使用。Redis5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。 复杂业务场景 ：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 bitmap 统计活跃用户、通过 sorted set 维护排行榜。 ","date":"2020-03-08","objectID":"/posts/redis%E5%9F%BA%E7%A1%80%E7%AF%87/:3:0","tags":["redis"],"title":"Redis","uri":"/posts/redis%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["数据库"],"content":"Redis 常见数据结构以及使用场景分析 ","date":"2020-03-08","objectID":"/posts/redis%E5%9F%BA%E7%A1%80%E7%AF%87/:4:0","tags":["redis"],"title":"Redis","uri":"/posts/redis%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["数据库"],"content":"string 介绍 ：string 数据结构是简单的 key-value 类型。虽然 Redis 是用 C 语言写的，但是 Redis 并没有使用 C 的字符串表示，而是自己构建了一种 简单动态字符串（simple dynamic string，SDS）。相比于 C 的原生字符串，Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）,除此之外，Redis 的 SDS API 是安全的，不会造成缓冲区溢出。 常用命令： set,get,strlen,exists,decr,incr,setex 等等。 应用场景： 一般常用在需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。 ","date":"2020-03-08","objectID":"/posts/redis%E5%9F%BA%E7%A1%80%E7%AF%87/:4:1","tags":["redis"],"title":"Redis","uri":"/posts/redis%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["数据库"],"content":"list 介绍 ：list 即是 链表。链表是一种非常常见的数据结构，特点是易于数据元素的插入和删除并且可以灵活调整链表长度，但是链表的随机访问困难。许多高级编程语言都内置了链表的实现比如 Java 中的 LinkedList，但是 C 语言并没有实现链表，所以 Redis 实现了自己的链表数据结构。Redis 的 list 的实现为一个 双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。 常用命令: rpush,lpop,lpush,rpop,lrange,llen 等。 应用场景: 发布与订阅或者说消息队列、慢查询。 ","date":"2020-03-08","objectID":"/posts/redis%E5%9F%BA%E7%A1%80%E7%AF%87/:4:2","tags":["redis"],"title":"Redis","uri":"/posts/redis%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["数据库"],"content":"hash 介绍 ：hash 类似于 JDK1.8 前的 HashMap，内部实现也差不多(数组 + 链表)。不过，Redis 的 hash 做了更多优化。另外，hash 是一个 string 类型的 field 和 value 的映射表，特别适合用于存储对象，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以 hash 数据结构来存储用户信息，商品信息等等。 常用命令： hset,hmset,hexists,hget,hgetall,hkeys,hvals 等。 应用场景: 系统中对象数据的存储。 ","date":"2020-03-08","objectID":"/posts/redis%E5%9F%BA%E7%A1%80%E7%AF%87/:4:3","tags":["redis"],"title":"Redis","uri":"/posts/redis%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["数据库"],"content":"set 介绍 ： set 类似于 Java 中的 HashSet 。Redis 中的 set 类型是一种无序集合，集合中的元素没有先后顺序。当你需要存储一个列表数据，又不希望出现重复数据时，set 是一个很好的选择，并且 set 提供了判断某个成员是否在一个 set 集合内的重要接口，这个也是 list 所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。比如：你可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。 常用命令： sadd,spop,smembers,sismember,scard,sinterstore,sunion 等。 应用场景: 需要存放的数据不能重复以及需要获取多个数据源交集和并集等场景 ","date":"2020-03-08","objectID":"/posts/redis%E5%9F%BA%E7%A1%80%E7%AF%87/:4:4","tags":["redis"],"title":"Redis","uri":"/posts/redis%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["数据库"],"content":"sorted set 介绍： 和 set 相比，sorted set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。有点像是 Java 中 HashMap 和 TreeSet 的结合体。 常用命令： zadd,zcard,zscore,zrange,zrevrange,zrem 等。 应用场景： 需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息。 ","date":"2020-03-08","objectID":"/posts/redis%E5%9F%BA%E7%A1%80%E7%AF%87/:4:5","tags":["redis"],"title":"Redis","uri":"/posts/redis%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["数据库"],"content":"bitmap 介绍： bitmap 存储的是连续的二进制数字（0 和 1），通过 bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 bitmap 本身会极大的节省储存空间。 常用命令： setbit 、getbit 、bitcount、bitop 应用场景： 适合需要保存状态信息（比如是否签到、是否登录…）并需要进一步对这些信息进行分析的场景。比如用户签到情况、活跃用户情况、用户行为统计（比如是否点赞过某个视频）。 ","date":"2020-03-08","objectID":"/posts/redis%E5%9F%BA%E7%A1%80%E7%AF%87/:4:6","tags":["redis"],"title":"Redis","uri":"/posts/redis%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["数据库"],"content":"Redis设置过期时间 127.0.0.1:6379\u003e exp key 60 # 数据在 60s 后过期 (integer) 1 127.0.0.1:6379\u003e setex key 60 value # 数据在 60s 后过期 (setex:[set] + [ex]pire) OK 127.0.0.1:6379\u003e ttl key # 查看数据还有多久过期 (integer) 56 ","date":"2020-03-08","objectID":"/posts/redis%E5%9F%BA%E7%A1%80%E7%AF%87/:5:0","tags":["redis"],"title":"Redis","uri":"/posts/redis%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["数据库"],"content":"过期的数据的删除策略 惰性删除 ：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。 定期删除 ： 每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。 定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 定期删除+惰性/懒汉式删除 。 但是还是有很多数据存放在redis内存中 还是会导致oom ","date":"2020-03-08","objectID":"/posts/redis%E5%9F%BA%E7%A1%80%E7%AF%87/:5:1","tags":["redis"],"title":"Redis","uri":"/posts/redis%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["java"],"content":"Spring生态系统：spring springMVC MyBaits (ssm) Spring生态系统 spring中引入bean spring+MyBatis （h2/MySQL/Postgres） 模板引擎（后端渲染HTML） FreeMarker Groovy Thymeleaf （Spring 官网使用这个） Velocity JSP 前后端分离和后端渲染 MVC :model view controller 数据 视图 controller ","date":"2020-03-04","objectID":"/posts/spring%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F/:0:0","tags":["spring"],"title":"Spring生态系统","uri":"/posts/spring%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F/"},{"categories":["java"],"content":"Spring生态系统中的主要子项目： Spring Framework：Spring项目的核心。IoC、AOP、MVC、JDBC、事务处理等等。 Spring Web Flow：Web工作流引擎，建立在Spring MVC基础之上。相对较独立于Spring Framework发展。 Spring BlazeDS Integration：提供Spring与Flex技术集成的模块。 Spring Security：基于Spring的认证和安全工具，基于Acegi框架。 Spring Security OAuth：对OAuth和Spring的集成提供支持。通过OAuth，桌面应用可以对Web应用进行简单、标准的安全调用。 Spring Dynamic Modules：可以让Spring应用运行在OSGI的平台上，如Eclipse，增加了应用再部署和运行时的灵活性。 Spring Batch：提供构建批处理应用和自动化操作的框架。 Spring Integration：企业级集成模式的实现。 Spring AMQP：为使用基于AMQP（高级消息队列协议）的消息服务提供支持。 Spring .NET：在.NET环境中使用Spring。 Spring Android：基于Java的REST客户端。 Spring Mobile：基于Spring MVC构建，为移动终端的服务器应用开发提供支持。 Spring Social：Spring框架的扩展，帮助Spring应用更方便的使用SNS。 Spring Data：为Spring 应用提供使用非关系型数据的能力。 Spring的原理和组成 封装一系列的开箱即用的组件功能： Spring JDBC SpringMVC Spring Security Spring AOP Spring ORM Spring Test Spring MVC User argent –http request — dispatcher Servlet —- handlerMapping —Controller —- ViewResolver —- Model —View Spring Boot Springboot 基本上是Spring框架的扩展，它消除了设置Spring应用程序所需的xml配置，为了更快更高效的开发生态系统 SpringBoot中一些特点： 创建独立的Spring应用 嵌入Tomcat，Jetty，Undertow而且不需要部署。 提供的 starters pom来简化Maven配置 尽可能自动部署spring应用 提供生产指标，健壮检查和外部化配置 ","date":"2020-03-04","objectID":"/posts/spring%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F/:1:0","tags":["spring"],"title":"Spring生态系统","uri":"/posts/spring%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F/"},{"categories":["java"],"content":"Spring Boot 的核心配置文件 Application配置文件主要用于Spring Boot项目的自动化配置 Bootstrap配置文件应用场景： 使用Spring Cloud Config配置中心时需要在bootstrap配置文件中添加连接到配置中心的配置属性来加载外部配置中心的配置信息。 一些固定的不能被覆盖的属性 一些加密/解密的场景 ","date":"2020-03-04","objectID":"/posts/spring%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F/:2:0","tags":["spring"],"title":"Spring生态系统","uri":"/posts/spring%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F/"},{"categories":["java"],"content":"Spring Boot 自动配置原理 @EnableAutoConfiguration，@Configuration，@ConditionalOnClass 得到配置文件，根据类路径下是否有这个类去自动配置。 ","date":"2020-03-04","objectID":"/posts/spring%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F/:3:0","tags":["spring"],"title":"Spring生态系统","uri":"/posts/spring%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F/"},{"categories":["java"],"content":"SpringBoot Starters ","date":"2020-03-04","objectID":"/posts/spring%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F/:4:0","tags":["spring"],"title":"Spring生态系统","uri":"/posts/spring%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F/"},{"categories":["java"],"content":"SpringBoot实现热部署 主要有两种方式： Spring Loaded Spring-boot-devtools ","date":"2020-03-04","objectID":"/posts/spring%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F/:5:0","tags":["spring"],"title":"Spring生态系统","uri":"/posts/spring%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F/"},{"categories":["java"],"content":"Spring-boot-starter-parent 我们在创建一个SpringBoot项目，默认都会有spring-boot-starter-parent主要有如下作用： 定义了java编译版本（现在还是1.8） 使用utf-8格式编码 继承spring-boot-dependencies，这个里边定义了依赖的版本，因此我们在写依赖时才不需要写版本号。 执行打包操作的配置 自动化的资源过滤 自动化的插件配置 针对application.properties和application.yml的资源过滤，包括profile定义的不同环境的配置文件，例如application-dev.properties和application-dev.yml ","date":"2020-03-04","objectID":"/posts/spring%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F/:6:0","tags":["spring"],"title":"Spring生态系统","uri":"/posts/spring%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F/"},{"categories":["java"],"content":"Spring中如何解决跨域问题 前端通过jsonp来解决，不过jsonp只可以发送GET请求，在RESTful风格的应用中就显得非常无助，因此我们推荐后端通过（CORS Cross-origin resource sharing）来解决跨域问题。 之前xml配置CORS，现在通过@CrossOrigin ","date":"2020-03-04","objectID":"/posts/spring%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F/:7:0","tags":["spring"],"title":"Spring生态系统","uri":"/posts/spring%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F/"},{"categories":["问题"],"content":"有关maven的问题 maven问题 ","date":"2020-03-03","objectID":"/posts/maven%E9%97%AE%E9%A2%98/:0:0","tags":["maven问题"],"title":"Maven问题","uri":"/posts/maven%E9%97%AE%E9%A2%98/"},{"categories":["问题"],"content":"maven本地仓库问题 打开IDEA -\u003e setting ，左上角搜索框输入：Maven 而一般情况下在2和3箭头指向的目录下面没有对应的settings.xml文件，我们可以新建一个settings.xml，并把下方的配置代码复制进去。需要注意的是，需要点击上图所示右下角的override。 。 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003csettings xmlns=\"http://maven.apache.org/SETTINGS/1.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd\"\u003e \u003cpluginGroups /\u003e \u003cproxies /\u003e \u003cservers /\u003e \u003clocalRepository\u003eD:/server/maven/repository\u003c/localRepository\u003e \u003cmirrors\u003e \u003cmirror\u003e \u003cid\u003ealimaven\u003c/id\u003e \u003cmirrorOf\u003ecentral\u003c/mirrorOf\u003e \u003cname\u003ealiyun maven\u003c/name\u003e \u003curl\u003ehttp://maven.aliyun.com/nexus/content/repositories/central/\u003c/url\u003e \u003c/mirror\u003e \u003cmirror\u003e \u003cid\u003ealimaven\u003c/id\u003e \u003cname\u003ealiyun maven\u003c/name\u003e \u003curl\u003ehttp://maven.aliyun.com/nexus/content/groups/public/\u003c/url\u003e \u003cmirrorOf\u003ecentral\u003c/mirrorOf\u003e \u003c/mirror\u003e \u003cmirror\u003e \u003cid\u003ecentral\u003c/id\u003e \u003cname\u003eMaven Repository Switchboard\u003c/name\u003e \u003curl\u003ehttp://repo1.maven.org/maven2/\u003c/url\u003e \u003cmirrorOf\u003ecentral\u003c/mirrorOf\u003e \u003c/mirror\u003e \u003cmirror\u003e \u003cid\u003erepo2\u003c/id\u003e \u003cmirrorOf\u003ecentral\u003c/mirrorOf\u003e \u003cname\u003eHuman Readable Name for this Mirror.\u003c/name\u003e \u003curl\u003ehttp://repo2.maven.org/maven2/\u003c/url\u003e \u003c/mirror\u003e \u003cmirror\u003e \u003cid\u003eibiblio\u003c/id\u003e \u003cmirrorOf\u003ecentral\u003c/mirrorOf\u003e \u003cname\u003eHuman Readable Name for this Mirror.\u003c/name\u003e \u003curl\u003ehttp://mirrors.ibiblio.org/pub/mirrors/maven2/\u003c/url\u003e \u003c/mirror\u003e \u003cmirror\u003e \u003cid\u003ejboss-public-repository-group\u003c/id\u003e \u003cmirrorOf\u003ecentral\u003c/mirrorOf\u003e \u003cname\u003eJBoss Public Repository Group\u003c/name\u003e \u003curl\u003ehttp://repository.jboss.org/nexus/content/groups/public\u003c/url\u003e \u003c/mirror\u003e \u003cmirror\u003e \u003cid\u003egoogle-maven-central\u003c/id\u003e \u003cname\u003eGoogle Maven Central\u003c/name\u003e \u003curl\u003ehttps://maven-central.storage.googleapis.com \u003c/url\u003e \u003cmirrorOf\u003ecentral\u003c/mirrorOf\u003e \u003c/mirror\u003e \u003c!-- 中央仓库在中国的镜像 --\u003e \u003cmirror\u003e \u003cid\u003emaven.net.cn\u003c/id\u003e \u003cname\u003eoneof the central mirrors in china\u003c/name\u003e \u003curl\u003ehttp://maven.net.cn/content/groups/public/\u003c/url\u003e \u003cmirrorOf\u003ecentral\u003c/mirrorOf\u003e \u003c/mirror\u003e \u003c/mirrors\u003e \u003c/settings\u003e 而repository则是Maven依赖的仓库，你可以根据自己的喜好进行设置 如果是linux系统，操作过程基本相同，只是settings.xml文件的存放路径不一样，不过都可以通过上面截图所示的页面中查到 ","date":"2020-03-03","objectID":"/posts/maven%E9%97%AE%E9%A2%98/:1:0","tags":["maven问题"],"title":"Maven问题","uri":"/posts/maven%E9%97%AE%E9%A2%98/"},{"categories":["java"],"content":"Cut out summary from your post content here. Spring ","date":"2020-03-02","objectID":"/posts/spring-web%E5%BA%94%E7%94%A8/:0:0","tags":["框架","Spring web"],"title":"Spring Web应用","uri":"/posts/spring-web%E5%BA%94%E7%94%A8/"},{"categories":["java"],"content":"从零开始⼀个Spring应⽤ pom.xml src/main/java/hello/Application.java src/main/java/hello/HelloController.java ","date":"2020-03-02","objectID":"/posts/spring-web%E5%BA%94%E7%94%A8/:1:0","tags":["框架","Spring web"],"title":"Spring Web应用","uri":"/posts/spring-web%E5%BA%94%E7%94%A8/"},{"categories":["java"],"content":"Web应⽤的本质 处理HTTP请求 从HTTP请求中提取query string (查询字符串) 从HTTP请求中接收payload（负载/body）中的参数 返回HTTP响应 status code HTTP response header HTTP response body JSON HTML … Get method 是幂等 (你发多少次都能看成一次) @RequestMapping(\"/search\") public String index(@RequestParam(\"q\")String searchWork, @RequestParam(value=\"charset\",required = false)String searchWork,) { return \"you search work is:\"+searchWork; } //RequestParam参数 你得看看源代码怎么写 ","date":"2020-03-02","objectID":"/posts/spring-web%E5%BA%94%E7%94%A8/:2:0","tags":["框架","Spring web"],"title":"Spring Web应用","uri":"/posts/spring-web%E5%BA%94%E7%94%A8/"},{"categories":["java"],"content":"HTTP GET Query string ?param1=value1\u0026param2=value2 通常⽤来传递⾮敏感信息 使⽤@RequestParam进⾏接收 ","date":"2020-03-02","objectID":"/posts/spring-web%E5%BA%94%E7%94%A8/:3:0","tags":["框架","Spring web"],"title":"Spring Web应用","uri":"/posts/spring-web%E5%BA%94%E7%94%A8/"},{"categories":["java"],"content":"RESTful API 使⽤HTTP动词来代表动作 GET：获取资源 POST：新建资源 PUT：更新资源 DELTE：删除资源 使⽤URL（名词）来代表资源 资源⾥⾯没有动词 使⽤复数来代表资源列表 ","date":"2020-03-02","objectID":"/posts/spring-web%E5%BA%94%E7%94%A8/:4:0","tags":["框架","Spring web"],"title":"Spring Web应用","uri":"/posts/spring-web%E5%BA%94%E7%94%A8/"},{"categories":["java"],"content":"@RestController 古老的用@Controller spring 2.5版本 使⽤RESTful⻛格的参数 使⽤@PathVariable进⾏参数提取 ","date":"2020-03-02","objectID":"/posts/spring-web%E5%BA%94%E7%94%A8/:5:0","tags":["框架","Spring web"],"title":"Spring Web应用","uri":"/posts/spring-web%E5%BA%94%E7%94%A8/"},{"categories":["java"],"content":"@PostMapping 处理POST请求 从HTTP POST请求中提取body ","date":"2020-03-02","objectID":"/posts/spring-web%E5%BA%94%E7%94%A8/:6:0","tags":["框架","Spring web"],"title":"Spring Web应用","uri":"/posts/spring-web%E5%BA%94%E7%94%A8/"},{"categories":["java"],"content":"⽣成HTTP响应 直接操作HttpServletResponse对象 原始、简单、粗暴 直接返回HTML字符串 原始、简单、粗暴 返回对象，并⾃动格式化成JSON 常⽤ @ResponseBody 模板引擎渲染 JSP/Velocity/Freemaker ","date":"2020-03-02","objectID":"/posts/spring-web%E5%BA%94%E7%94%A8/:7:0","tags":["框架","Spring web"],"title":"Spring Web应用","uri":"/posts/spring-web%E5%BA%94%E7%94%A8/"},{"categories":["java"],"content":"周边⽣态系统 HTTPS 分布式部署 扩展功能 数据库 Redis缓存 消息队列 RPC（Dubbo/Spring Cloud） 微服务化 获取参数 query string RESTAPI body …… 这是spring mvc提供的自动参数绑定 绑定参数@PathVariable(“参数名”) header 中的type属性能告诉 xxx body是什么东西 requsetMapping、postMapping…… ","date":"2020-03-02","objectID":"/posts/spring-web%E5%BA%94%E7%94%A8/:8:0","tags":["框架","Spring web"],"title":"Spring Web应用","uri":"/posts/spring-web%E5%BA%94%E7%94%A8/"},{"categories":["Docker"],"content":"Docker? Docker Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。 Docker通常用于如下场景： web应用的自动化打包和发布； 自动化测试和持续集成、发布； 在服务型环境中部署和调整数据库或其他的后台应用； 从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境。 Docker pull \u003c仓库\u003e\u003cimage/镜像\u003e\u003c版本\u003e 仓库默认是docker 版本默认laster Docker images Docker container ls -a Docker start \u003cid/name\u003e Docker container start \u003cid/name\u003e Docker stop \u003cid/name\u003e 如果id前几个字符没重复就不用全写 Docker run 后面是image的参数命令 没创建证明报错用 -it 看看报什么错 Docker run -it 后面是image的参数命令 用完就删除container Docker run -d 后面是image的参数命令 参数命令例子：bash（进入交互命令行） Docker run –name -v :-p :-e \u003c环境变量名==xxx 例如：mysqlName and password\u003e -d Docker rm \u003cid/name\u003e 在此次之前要stop，那为什么rm -rf 就可以 Docker exec \u003cid/name\u003e Docker logs \u003cid/name\u003e Docker logs -f \u003cid/name\u003e Docker inspect \u003cid/name\u003e Docker tag \u003cid/name\u003e 127.0.0.1:5000/文件路径/文件名:版本号 Docker pull 127.0.0.1:5000/文件路径/文件名:版本号 如何显示出来/访问：例子：localhost:8080/文件路径/文件名/tags/list 具体如何要自己上网查查 ","date":"2020-03-02","objectID":"/posts/docker/:0:0","tags":["docker"],"title":"Docker","uri":"/posts/docker/"},{"categories":["Docker"],"content":"Docker改变了了软件世界 在Docker出现之前…… 软件在操作系统上是如何工作的？ 如何交付软件？ 如何部署软件？ Docker出现之后…… ","date":"2020-03-02","objectID":"/posts/docker/:1:0","tags":["docker"],"title":"Docker","uri":"/posts/docker/"},{"categories":["Docker"],"content":"Docker能做什什么？ 保证开发、测试、交付、部署的环境完全一致 保证资源的隔离 启动临时的、⽤用完即弃的环境，例如测试 迅速（秒级）超大规模部署和扩容 ","date":"2020-03-02","objectID":"/posts/docker/:2:0","tags":["docker"],"title":"Docker","uri":"/posts/docker/"},{"categories":["Docker"],"content":"Docker的基本概念 镜像 image 一个预先定义好的模板⽂文件，Docker引擎可以按照这个模板 ⽂文件启动⽆无数个一模一样，互不干扰的容器 容器 container 一台虚拟的计算机，拥有独⽴的： 网络 文件系统 进程 默认和宿主机不不发生任何交互 意味着数据是没有持久化的！ ","date":"2020-03-02","objectID":"/posts/docker/:3:0","tags":["docker"],"title":"Docker","uri":"/posts/docker/"},{"categories":["Docker"],"content":"docker pull/images 下载一个指定的镜像，⽅方便便随时启动 docker pull mysql:5.7.28 下载指定镜像 docker images 查看本地已有的镜像 registry.cn-beijing.aliyuncs.com/dr1/hcsp:0.0.16 镜像仓库镜像名tag ","date":"2020-03-02","objectID":"/posts/docker/:4:0","tags":["docker"],"title":"Docker","uri":"/posts/docker/"},{"categories":["Docker"],"content":"docker run/ps docker run装载镜像成为一个容器器 就好像从蛋糕模⼦子做出来一个蛋糕 在这个容器看来，自己就是一台独⽴立的计算机 每个容器有⼀一个ID，支持缩写 docker run -it \u003c镜像名\u003e \u003c镜像中要运行的命令和参数\u003e 没填image参数默认是bash dockerfile有写得 交互式命令行，当前shell中运行，Ctrl-C退出 docker run -d \u003c镜像名\u003e \u003c镜像中要运行的命令和参数\u003e daemon模式，在后台运⾏行行 ","date":"2020-03-02","objectID":"/posts/docker/:5:0","tags":["docker"],"title":"Docker","uri":"/posts/docker/"},{"categories":["Docker"],"content":"docker run 常用的参数 –name 为容器指定一个「名字」 –restart=always 遇到错误自动重启 -v \u003c本地文件\u003e:\u003c容器文件\u003e -p \u003c本地端口\u003e:\u003c容器端口\u003e -e NAME=VALUE ","date":"2020-03-02","objectID":"/posts/docker/:6:0","tags":["docker"],"title":"Docker","uri":"/posts/docker/"},{"categories":["Docker"],"content":"docker start/stop 启动/停止一个容器 可以想象为开关机 ","date":"2020-03-02","objectID":"/posts/docker/:7:0","tags":["docker"],"title":"Docker","uri":"/posts/docker/"},{"categories":["Docker"],"content":"docker rm 删除⼀一个容器 想象成将电脑丢掉 ","date":"2020-03-02","objectID":"/posts/docker/:8:0","tags":["docker"],"title":"Docker","uri":"/posts/docker/"},{"categories":["Docker"],"content":"docker exec 指定目标容器，进⼊入容器执行命令 docker run -it \u003c目标容器ID\u003e \u003c目标命令（通常为bash）\u003e 可以「想象」成ssh 调试、解决问题必备命令 ","date":"2020-03-02","objectID":"/posts/docker/:9:0","tags":["docker"],"title":"Docker","uri":"/posts/docker/"},{"categories":["Docker"],"content":"docker logs docker logs \u003c容器ID或容器名\u003e 查看目标容器器的输出 docker logs -f \u003c容器ID或容器名\u003e ","date":"2020-03-02","objectID":"/posts/docker/:10:0","tags":["docker"],"title":"Docker","uri":"/posts/docker/"},{"categories":["Docker"],"content":"docker inspect 高级命令，可以无视 查看容器的详细状态 ","date":"2020-03-02","objectID":"/posts/docker/:11:0","tags":["docker"],"title":"Docker","uri":"/posts/docker/"},{"categories":["Docker"],"content":"分层的镜像 图片自己补全 ","date":"2020-03-02","objectID":"/posts/docker/:12:0","tags":["docker"],"title":"Docker","uri":"/posts/docker/"},{"categories":["Docker"],"content":"Dockerfile 指定镜像如何⽣生成 编写第一个Dockerfile docker build . 每个镜像会有一个唯一的ID ","date":"2020-03-02","objectID":"/posts/docker/:13:0","tags":["docker"],"title":"Docker","uri":"/posts/docker/"},{"categories":["Docker"],"content":"Docker的镜像仓库与tag 可以任意对镜像进行tag操作 决定了未来这个镜像会被push到哪⾥ 决定了未来从哪⾥载镜像 可以方便的创建镜像仓库的私服 –registry-mirror –insecure-registry ","date":"2020-03-02","objectID":"/posts/docker/:14:0","tags":["docker"],"title":"Docker","uri":"/posts/docker/"},{"categories":["Docker"],"content":"Docker与K8s 图片 ","date":"2020-03-02","objectID":"/posts/docker/:15:0","tags":["docker"],"title":"Docker","uri":"/posts/docker/"},{"categories":["Docker"],"content":"Docker与Kubernetes 图片 ","date":"2020-03-02","objectID":"/posts/docker/:16:0","tags":["docker"],"title":"Docker","uri":"/posts/docker/"},{"categories":["数据库"],"content":"mysql相关知识 mysql ","date":"2020-03-02","objectID":"/posts/mysql/:0:0","tags":["MySQL"],"title":"MySQL","uri":"/posts/mysql/"},{"categories":["数据库"],"content":"存储方式 B+树 b树 b*树 好处：1.多叉树，多个子节点（节点多个记录） so 高度低 方便io ","date":"2020-03-02","objectID":"/posts/mysql/:1:0","tags":["MySQL"],"title":"MySQL","uri":"/posts/mysql/"},{"categories":["数据库"],"content":"联合索引 Create index index_name on news(字段名 或者 字段名(length)) 范围查找索引用处不大，而且后面的索引是用不到的 你建的是（a,b,c,d）索引 最左前缀匹配 优先级类型 Explain select * from NEWS where created_at =xxx and modified_at =xxx 时间的时分秒去掉，=对应索引来说性能提升是最大的 Mysql 不擅长文本类的索引 ","date":"2020-03-02","objectID":"/posts/mysql/:2:0","tags":["MySQL"],"title":"MySQL","uri":"/posts/mysql/"},{"categories":["数据库"],"content":"Elasticsearch Elasticsearch Bulk (一次性发多个请求) BulkRequest bulkRequest=new BulkRequest() bulkRequest.add(request); client.bulk(bulkRequest , RequestOptions.DEFAULT) ","date":"2020-03-02","objectID":"/posts/elasticsearch/:0:0","tags":["Elasticsearch"],"title":"Elasticsearch","uri":"/posts/elasticsearch/"},{"categories":["问题"],"content":"各种的字符乱码解决方案 MySQL 设置数据库编码 CREATEDATABASEnewsDEFAULTCHARSETutf8mb4COLLATE=utf8mb4_unicode_ci;设置数据表编码 CREATETABLE'author'('authorid'char(20)NOTNULL,'name'char(20)NOTNULL,'age'char(20)NOTNULL,'country'char(20)NOTNULL)ENGINE=InnoDBDEFAULTCHARSET=utf8AUTO_INCREMENT=1;mysql中两种数据库引擎 ENGINE=MyISAM ENGINE=InnoDB ","date":"2020-02-28","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/:0:0","tags":["字符乱码问题"],"title":"数据库字符编码问题","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/"},{"categories":["html"],"content":"URL是什么，它由什么组成 1990 年英国计算机科学家蒂姆·伯纳斯-李（Tim Berners-Lee）发明了万维网，并解决了其中三项关键技术： URL + HTML + HTTP。 本篇讲述其中的一项，全球网络资源唯一认证的系统：URL 的基本知识。 URL 传送协议：后接层级 URL 标记符号 // ，可省略 —\u003e // 开头的无协议地址 服务器域名：也可以是 IP 地址，前者会被 DNS 解析 端口号：以数字形式表示，若为默认值可省略 路径：以 / 字符区别路径中 每一个目录名称，通过路径可以访问服务器的不同页面 查询字符串：以 ? 为起点，用 = 划分参数名与数据，每个参数以 \u0026 隔开，查询参数实现了对同个页面不同内容的访问 锚点：以 # 为起点，用于跳转到该页面的某个位置，锚点只和本地的游览器有关，其参数不会在请求头中传给服务器 ","date":"2020-02-23","objectID":"/posts/%E6%B5%85%E6%9E%90-url/:0:0","tags":["URL"],"title":"浅析 URL","uri":"/posts/%E6%B5%85%E6%9E%90-url/"},{"categories":["html"],"content":"http/https 简单来说一个安全https，一个不安全http http 是无状态 ","date":"2020-02-23","objectID":"/posts/%E6%B5%85%E6%9E%90-url/:1:0","tags":["URL"],"title":"浅析 URL","uri":"/posts/%E6%B5%85%E6%9E%90-url/"},{"categories":["html"],"content":"IP 与 DNS域名系统 一个域名 —— 多IP ：负载均衡，防止一台主机扛不住 一个IP —— 多域名 ：共享主机，很懂得 利(穷) 用(开) 资(发) 源(者) IP 和端口的作用 **IP（Internet Protocal）**是定位互联网中一台设备的协议，它规定了如何封装数据报文，以跟互联网中的其他设备交流。只要你在互联网中，你就至少有一个独特的 IP。 **端口（Port）**是用来定位互联网中一台设备中的不同服务的。 内网与外网 外网: Internet —— 路由器 内网：路由器 —— 家里网络 外网和内网之间使用路由器进行中转（网关）。 ","date":"2020-02-23","objectID":"/posts/%E6%B5%85%E6%9E%90-url/:2:0","tags":["URL"],"title":"浅析 URL","uri":"/posts/%E6%B5%85%E6%9E%90-url/"},{"categories":["html"],"content":"外网 IP 当我们租用电信宽带，安装猫和路由器后，便拥有了自己的外网 IP（由运营商分配）。需要注意的是，你的所有设备都共享一个外网 IP；如果重启路由器，外网 IP 将会被重新分配。 可以通过 ipconfig 或访问 IP 138.com 来查看自己的外网 IP。 ","date":"2020-02-23","objectID":"/posts/%E6%B5%85%E6%9E%90-url/:2:1","tags":["URL"],"title":"浅析 URL","uri":"/posts/%E6%B5%85%E6%9E%90-url/"},{"categories":["html"],"content":"内网 IP 内网 IP 一般以 192.168.x.x 形式出现，内网中的设备可以互相访问，但想访问外网需要通过路由器中转；同样地，外网设备要把数据内容送到内网也必须通过路由器。 路由器可以说是内网和外网这两个隔绝空间之间的唯一连通点，故也被称为网关。 ","date":"2020-02-23","objectID":"/posts/%E6%B5%85%E6%9E%90-url/:2:2","tags":["URL"],"title":"浅析 URL","uri":"/posts/%E6%B5%85%E6%9E%90-url/"},{"categories":["html"],"content":"几个特殊的 IP localhost = 127.0.0.1 0.0.0.0 不表示任何设备 ","date":"2020-02-23","objectID":"/posts/%E6%B5%85%E6%9E%90-url/:2:3","tags":["URL"],"title":"浅析 URL","uri":"/posts/%E6%B5%85%E6%9E%90-url/"},{"categories":["html"],"content":"DNS Domain Name System 将域名和 IP 连接起来 通常我们在游览器中输入的是服务器的域名而不是 IP 地址，此时 chrome 游览器会向电信 / 联通提供的 DNS 服务器询问域名对应的 IP 地址。 然后 chrome 游览器会向对应的 IP 的 80 / 443 端口发送请求。 服务器返回响应体，被游览器解析成丰富多彩的网页内容。 可以通过 nslookup baidu.com 向 DNS 询问域名对应的 IP 地址。 一个域名可以对应不同的 IP，实现均衡负载；一个 IP 也可以对应不同的域名，叫共享主机，即和别的公司共用服务器。 可以通过 curl -v http://www.baidu.com 发送 HTTP 请求。 ","date":"2020-02-23","objectID":"/posts/%E6%B5%85%E6%9E%90-url/:2:4","tags":["URL"],"title":"浅析 URL","uri":"/posts/%E6%B5%85%E6%9E%90-url/"},{"categories":["html"],"content":"域名的级别 .com 为顶级域名，xiedaimala.com 为二级域名，每一级的域名控制它下一级域名的分配。 顶级域名有国家顶级域名：cn、us、jp 等，和国际顶级域名：.com（工商企业）、.net（网络提供商）、.org（非盈利组织） 等。 三级域名是二级域名的子域名，是二级域名的附属物而无需单独付费。 不加 www 的裸域名也可以正常运作，且更加简短、容易记忆。 ","date":"2020-02-23","objectID":"/posts/%E6%B5%85%E6%9E%90-url/:2:5","tags":["URL"],"title":"浅析 URL","uri":"/posts/%E6%B5%85%E6%9E%90-url/"},{"categories":["html"],"content":"端口 端口的约定 当数据内容通过外网及内网 IP 唯一定位到用户设备后，需要通过端口传输给指定的服务。常用的服务有：端口列表 HTTP 服务：80 端口 HTTPS 服务：443 端口 FTP 服务：21 端口 关于端口有几个约定： 一共有 65535 个端口可供使用，0~1023 号端口是留给系统使用的。 只有拥有管理员权限后，才能使用这 1024 个端口；其他端口是给普通用户使用的，比如 http-server 默认使用 8080 端口。 ","date":"2020-02-23","objectID":"/posts/%E6%B5%85%E6%9E%90-url/:3:0","tags":["URL"],"title":"浅析 URL","uri":"/posts/%E6%B5%85%E6%9E%90-url/"},{"categories":["html"],"content":"a 、img 、table 标签的用法 HTML常用标签 ","date":"2020-02-23","objectID":"/posts/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:0:0","tags":["常用标签"],"title":"HTML常用标签","uri":"/posts/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["html"],"content":"a标签 属性 href (hyper reference) target download rel=noopener a标签作用 跳转到网页、锚点、邮箱和电话 为了防止window.opener被滥用，在使用targrt=_blank时需要加上rel=noopener \u003ca href=\"www.baidu.com\" target=\"_blank\" rel=\"noopener\" \u003e 属性href取值 网址 路径 id=xxx（锚点） 伪协议 ：javascript、mailto、tel 属性target取值 内置名字 _blank (new tab) _top (用顶部打开) _parent （上一级打开） _self （自己打开，默认） 其他命名 window的name (new tab’s name) iframe的name 属性download 作用 ：不打开只下载 不是所用的浏览器都支持，尤其是手机浏览器可能不支持 iframe标签 内嵌标签 table标签 相关样式 table-layout border-collapse border-spacing border-collapse: collapse; 因为默认是没合并有空隙，默认样式很丑所以用collapse \u003c!-- tr:table row th:table head一列 td:table data --\u003e \u003cthead\u003e \u003ctr\u003e \u003cth colspan=\"2\"\u003eThe table header\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003eThe table body\u003c/td\u003e \u003ctd\u003ewith two columns\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003ctfoot\u003e \u003c/tfoot\u003e \u003c/table\u003e img标签 作用 发出get请求，展示图片 属性 alt/height/width/src(source) 不要同时height/width，除非有规定，不然是破坏原本比例 事件 onload/onerror 响应式 max-width:100% 可替换元素 form标签 作用 发送get和post请求，然后刷新页面 属性 action (提交到的响应页面) autocomplete method (get and post) target (与a标签target) 事件 onsubmit \u003cform action=\"\" method=\"get\" \u003e \u003cdiv\u003e \u003clabel for=\"name\"\u003eEnter your name: \u003c/label\u003e \u003cinput type=\"text\" name=\"name\" id=\"name\" required\u003e \u003c/div\u003e \u003cdiv\u003e \u003clabel for=\"email\"\u003eEnter your email: \u003c/label\u003e \u003cinput type=\"email\" name=\"email\" id=\"email\" required\u003e \u003c/div\u003e \u003cdiv\u003e \u003cinput type=\"submit\" value=\"提交\"\u003e \u003c/div\u003e \u003c/form\u003e \u003c!-- button能有额外功能，例如加个\u003cbr\u003e --\u003e \u003cinput type=\"submit\" value=\"提交\"\u003e \u003cbutton type=\"submit\" \u003e提交\u003c/button\u003e ","date":"2020-02-23","objectID":"/posts/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:1:0","tags":["常用标签"],"title":"HTML常用标签","uri":"/posts/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["html"],"content":"input标签 作用：输入内容 属性：button/checkbox/file/hidden/text/submit/… 事件：onchange/onfocus/onblur 注意事项 一般不监听input的click事件 form里面的input要有name form里面要发一个submit才能触发submit事件 ","date":"2020-02-23","objectID":"/posts/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:2:0","tags":["常用标签"],"title":"HTML常用标签","uri":"/posts/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["java"],"content":"spring? , ?要用spring , Spring怎么用? , 怎么实现？ spring Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架。 Spring MVC 基于Spring和Servlet的Web应用框架 Spring Boot 集成度和自动化程度更高 servlet server ~let 是小的意思 servlet 小服务器 代表例子Tomcat Jetty servlet把http请求 封装成对象 给webapp ","date":"2020-02-21","objectID":"/posts/spring/:0:0","tags":["spring"],"title":"Spring","uri":"/posts/spring/"},{"categories":["java"],"content":"没spring前 main 方便但多了代码是灾难 model(模块化) 方便维护，但依赖关系复杂 ","date":"2020-02-21","objectID":"/posts/spring/:1:0","tags":["spring"],"title":"Spring","uri":"/posts/spring/"},{"categories":["java"],"content":"spring容器 bean是豆意思，在spring是一个容器中最小工作单元，其实是一个java对象， BeanFactory/ApplicationContext 容器本身对应的java对象 依赖注入（DI） Dependency Injection （spring帮你实例化对象中加些属性，那些属性有你xml，properties等等写上的相关依赖） 都是单例的？？ @Autowired @Resource @Inject 用Autowired就要在xml 加\u003ccontext:autotation-config /\u003e 控制反转（IoC）Inversion of Control 自己只需要声明什么依赖什么，有东西会帮你自动组装好 使用步骤 bean id= class=… \u003e 在xml里面 依赖要而外配置 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"\u003e \u003c!-- 识别@Autowried --\u003e \u003ccontext:autotation-config /\u003e \u003c!-- 配置bean --\u003e \u003cbean id=\"id名字\" class=\"全限定类名\"/\u003e \u003cbean id=\"id名字\" class=\"全限定类名\"/\u003e \u003cbean id=\"id名字\" class=\"全限定类名\"/\u003e \u003c/beans\u003e 不会自己手写ioc容器，它的步骤是什么？ 定义Bean (properties/xml/…) 加载bean定义 实例化bean (用map存) 查找依赖，实现自动注入(动态字节码加属性) //projectName: simple-ioc0-container public class MyIoCContainer { // 实现一个简单的IoC容器，使得： // 1. 从beans.properties里加载bean定义 // 2. 自动扫描bean中的@Autowired注解并完成依赖注入 public static void main(String[] args) { MyIoCContainer container = new MyIoCContainer(); container.start(); OrderService orderService = (OrderService) container.getBean(\"orderService\"); orderService.createOrder(); } Map\u003cString, Object\u003e beans = new HashMap\u003c\u003e(); // 启动该容器 public void start() { Properties properties = new Properties(); try { properties.load(MyIoCContainer.class.getResourceAsStream(\"/beans.properties\")); } catch (IOException e) { throw new RuntimeException(e); } //往beans加入实例对象 //beanName用的是 属性名而不是类型名称，看properties就知道了 properties.forEach((beanName, beanClass) -\u003e { try { Class\u003c?\u003e klass = Class.forName((String) beanClass); Object beanInstance = klass.getDeclaredConstructor().newInstance(); beans.put((String) beanName, beanInstance); } catch (Exception e) { throw new RuntimeException(e); } }); beans.forEach(this::dependencyInject); } //只用Autowried依赖来举例子（实际上还有很多依赖） private void dependencyInject(String beanName, Object beanInstance) { List\u003cField\u003e dependencyInject = Stream.of(beanInstance.getClass().getDeclaredFields()) .filter(field -\u003e field.getAnnotation(Autowired.class) != null) .collect(Collectors.toList()); dependencyInject.forEach(field -\u003e { try { String fieldName = field.getName(); Object dependencyBeanInstance = beans.get(fieldName); field.setAccessible(true); field.set(beanInstance, dependencyBeanInstance); } catch (IllegalAccessException e) { throw new RuntimeException(e); } }); } // 从容器中获取一个bean public Object getBean(String beanName) { return beans.get(beanName); } } Bean的定义除获取xml还有java支持的properties ","date":"2020-02-21","objectID":"/posts/spring/:2:0","tags":["spring"],"title":"Spring","uri":"/posts/spring/"},{"categories":["java"],"content":"默认情况下是不给修改private成员，怎么办？ Field.setAccessible(true) ","date":"2020-02-21","objectID":"/posts/spring/:2:1","tags":["spring"],"title":"Spring","uri":"/posts/spring/"},{"categories":["java"],"content":"在创建实例中的循环依赖是没办法解决的","date":"2020-02-21","objectID":"/posts/spring/:2:2","tags":["spring"],"title":"Spring","uri":"/posts/spring/"},{"categories":["java"],"content":"ORM：Object Relational Mapping 对自己梳理清晰逻辑前言： 对于复杂的需求，Mybatis 比较复杂 方法要传入什么参数（sql需要的 或者 形成sql参数所需要参数 ） 我觉得先什么都不写，先返回方法参数类型 要分清 mapper.xml中sql 的parameterType resultType Mybatis 在调用时候你会觉得有点不对用的是mybatis包名是ibatis： 版本1和2是包名 ibatis 版本3是mybatis 因为向后兼容所以没改 xml的属性要顺序的不然报错（config.xml 中的settings、typeAliases、environments、mappers） ⾸先配置⽇志框架，可以极⼤地提⾼排查问题的效率 然后配置数据源 Mapper：接⼝由MyBatis动态代理 优点：⽅便 缺点：SQL复杂的时候不够⽅便 Mapper：⽤XML编写复杂SQL 优点：可以⽅便地使⽤MyBatis的强⼤功能 缺点：SQL和代码分离 ","date":"2020-02-19","objectID":"/posts/mybatis/:0:0","tags":["数据库","ORM"],"title":"Mybatis","uri":"/posts/mybatis/"},{"categories":["java"],"content":"Object Relationship Mapping 对象关系映射 ⾃动完成对象到数据库的映射 Association(对象套对象) ⾃动装配对象 \u003cselect id=\"getInnerJoinOrders\" resultMap=\"Order\"\u003e select `ORDER`.ID as ORDER_ID ,USER.NAME as USER_NAME , GOODS.NAME as GOODS_NAME , (`ORDER`.GOODS_PRICE * `ORDER`.GOODS_NUM) as TOTAL_PRICE from `ORDER` inner join USER on `ORDER`.USER_ID=USER.id inner join GOODS on `ORDER`.GOODS_ID=GOODS.id where GOODS.NAME is not null and USER.NAME is not null \u003c/select\u003e \u003cresultMap type=\"Order\" id=\"Order\"\u003e \u003cresult property=\"id\" column=\"ORDER_ID\"/\u003e \u003cresult property=\"totalPrice\" column=\"TOTAL_PRICE\"/\u003e \u003cassociation property=\"user\" javaType=\"User\"\u003e \u003cresult property=\"name\" column=\"USER_NAME\"/\u003e \u003c/association\u003e \u003cassociation property=\"goods\" javaType=\"Goods\"\u003e \u003cresult property=\"name\" column=\"GOODS_NAME\"/\u003e \u003c/association\u003e \u003c/resultMap\u003e public void batchInsertUsers(List\u003cUser\u003e users) { try (SqlSession sqlSession = sqlSessionFactory.openSession(true)) { sqlSession.selectOne(\"Mapper.batchInsertUsers\", users); } } ","date":"2020-02-19","objectID":"/posts/mybatis/:1:0","tags":["数据库","ORM"],"title":"Mybatis","uri":"/posts/mybatis/"},{"categories":["java"],"content":"Mapper parameterType 参数的#{}和${} （防不防sql注入） 参数是按照Java Bean约定读取的:getter/setter resultType typeAlias 写参数是按照Java Bean约定的:getter/setter Association(对象套对象) typeAliases 别名 \u003ctypeAliases\u003e \u003ctypeAliase aliase=\"User\" type=\"全限定类名\"\u003e \u003c/typeAliases\u003e ","date":"2020-02-19","objectID":"/posts/mybatis/:2:0","tags":["数据库","ORM"],"title":"Mybatis","uri":"/posts/mybatis/"},{"categories":["java"],"content":"动态SQL——MyBatis的灵魂 if choose foreach script \u003c!-- 建议官方文档下面代码只是方便自己回归 --\u003e \u003c!-- java代码省略 --\u003e \u003c!-- \u003cif\u003e --\u003e \u003cselect id=\"getUserByPage\" parameterType=\"Map\" resultType=\"User\"\u003e select id,name,tel,address from USER \u003cif test=\"username != null\"\u003e where name = #{username} \u003c/if\u003e limit #{offset} , #{limit} ; \u003c/select\u003e \u003c!-- \u003cforeach\u003e --\u003e \u003cinsert id=\"batchInsertUsers\" parameterType=\"java.util.List\"\u003e insert into USER (name,tel,address) values \u003cforeach collection=\"list\" item=\"user\" separator=\",\"\u003e (#{user.name},#{user.tel},#{user.address}) \u003c/foreach\u003e \u003c/insert\u003e ","date":"2020-02-19","objectID":"/posts/mybatis/:3:0","tags":["数据库","ORM"],"title":"Mybatis","uri":"/posts/mybatis/"},{"categories":["java"],"content":"MyBatis的缓存 缓存是如何⼯作的？ MyBatis缓存源代码深⼊解读 Decorator模式 ","date":"2020-02-19","objectID":"/posts/mybatis/:4:0","tags":["数据库","ORM"],"title":"Mybatis","uri":"/posts/mybatis/"},{"categories":["java"],"content":"MyBatis MapperProxy 动态字节码增强? public User selectUserById(Integer id) { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { final SelectMap mapper = sqlSession.getMapper(SelectMap.class); return mapper.SelectIdGetUser(id); } } interface SelectMap { @Select(\"Select * from USER where id =#{id}\") User SelectIdGetUser(@Param(\"id\") Integer id); } 还有在config.xml 配置mapper class=\"…..\" 返回的类型User 是通过JavaBean约定 （调试器会调到get/set方法里面去） ","date":"2020-02-19","objectID":"/posts/mybatis/:5:0","tags":["数据库","ORM"],"title":"Mybatis","uri":"/posts/mybatis/"},{"categories":["java"],"content":"MyBatis字符 Utf8 utf8mb4 数据库 在mybatis中有一个驼峰形式 xx_xx to xxXx mybatis.configuration.mapUnderscoreToCamelCase=ture Session.commit() 等等 if catch(){ session.rollback(); } Session.flushStatements(); ","date":"2020-02-19","objectID":"/posts/mybatis/:6:0","tags":["数据库","ORM"],"title":"Mybatis","uri":"/posts/mybatis/"},{"categories":["java"],"content":"?注解，有哪些注解，?创建注解,?获得注解，注解怎么被处理? 怎么能找到处理注解代码？ 注解Annotation 注解就是说明书中的⼀⼩段信息/⽂本/标记。只提供信息，不做处理 默认extends Annotation 可以携带参数 可以在运⾏时被阅读 ","date":"2020-02-16","objectID":"/posts/%E6%B3%A8%E8%A7%A3/:0:0","tags":["注解","反射"],"title":"注解","uri":"/posts/%E6%B3%A8%E8%A7%A3/"},{"categories":["java"],"content":"元注解 @Target 注解能放在哪里 @Retention SOURCE CLASS RUNTIME @Documented @Inherited 继承，子类能看到注解 @Repeatable ","date":"2020-02-16","objectID":"/posts/%E6%B3%A8%E8%A7%A3/:1:0","tags":["注解","反射"],"title":"注解","uri":"/posts/%E6%B3%A8%E8%A7%A3/"},{"categories":["java"],"content":"JDK的⾃带注解 @Deprecated @Override @SuppressWarnings @FunctionalInterface ","date":"2020-02-16","objectID":"/posts/%E6%B3%A8%E8%A7%A3/:2:0","tags":["注解","反射"],"title":"注解","uri":"/posts/%E6%B3%A8%E8%A7%A3/"},{"categories":["java"],"content":"注解的属性 基本数据类型 + String + 类(Class) + 以及它们的数组 默认值 名为value的属性 public @interface 洗涤手段{ String value() default \"水洗\";//也可以 String[] , 默认值可不加 类型 名为xxx属性() } //用注解例子 @洗涤手段 //默认是水洗 @xxx(value={\"干洗\",\"水洗\"}, xxx=xxx) //用String[]类型例子 获取注解 通过反射 1. Method.getAnnotation 2. Class.getAnnotation ","date":"2020-02-16","objectID":"/posts/%E6%B3%A8%E8%A7%A3/:3:0","tags":["注解","反射"],"title":"注解","uri":"/posts/%E6%B3%A8%E8%A7%A3/"},{"categories":["java"],"content":"注解是怎么工作 在运行时候通过反射来生效 动态字节码增强：其中之一btyebuddy public static \u003cT\u003e Class\u003cT\u003e decorate(Class\u003cT\u003e klass) { return (Class\u003cT\u003e) new ByteBuddy() .subclass(klass) .method(ElementMatchers.isAnnotatedWith(Cache.class)) .intercept(MethodDelegation.to(CacheAdvisor.class)) .make() .load(klass.getClassLoader()) .getLoaded(); } //ElementMatchers和MethodDelegation是ByteBuddy自带 //没写CacheKey, CacheValue类自己补全吧 public static class CacheAdvisor { private static ConcurrentHashMap\u003cCacheKey, CacheValue\u003e cache = new ConcurrentHashMap\u003c\u003e(); //运行时候能识别 @RuntimeType public static Object cache( @SuperCall Callable\u003cObject\u003e superCall, @Origin Method method, @This Object thisObject, @AllArguments Object[] arguments) throws Exception { //真的需要final？？？ CacheKey cacheKey = new CacheKey(thisObject, method.getName(), arguments); final CacheValue resultExistingInCache = cache.get(cacheKey); if (resultExistingInCache != null) { if (cacheExpires(resultExistingInCache, method)) { return invokeRealMethodAndPutIntoCache(superCall, cacheKey); } else { return resultExistingInCache.value; } } else { return invokeRealMethodAndPutIntoCache(superCall, cacheKey); } } private static Object invokeRealMethodAndPutIntoCache(@SuperCall Callable\u003cObject\u003e superCall, CacheKey cacheKey) throws Exception { Object methodResult = superCall.call(); cache.put(cacheKey, new CacheValue(methodResult, System.currentTimeMillis())); return methodResult; } private static boolean cacheExpires(CacheValue cacheValue, Method method) { long time = cacheValue.time; int cacheSeconds = method.getAnnotation(Cache.class).cacheSeconds(); return System.currentTimeMillis() - time \u003e cacheSeconds * 1000; } } ","date":"2020-02-16","objectID":"/posts/%E6%B3%A8%E8%A7%A3/:4:0","tags":["注解","反射"],"title":"注解","uri":"/posts/%E6%B3%A8%E8%A7%A3/"},{"categories":["java"],"content":"java是假泛型！！！ 泛型 ","date":"2020-02-16","objectID":"/posts/java%E6%B3%9B%E5%9E%8B/:0:0","tags":["泛型"],"title":"Java泛型","uri":"/posts/java%E6%B3%9B%E5%9E%8B/"},{"categories":["java"],"content":"泛型历史 jdk5才有泛型 之前怎么保证类型安全？ 创建新的装饰器来保证类型安全 因为java保证向后兼容性 java选择假泛型 C#选择重新新API ","date":"2020-02-16","objectID":"/posts/java%E6%B3%9B%E5%9E%8B/:1:0","tags":["泛型"],"title":"Java泛型","uri":"/posts/java%E6%B3%9B%E5%9E%8B/"},{"categories":["java"],"content":"泛型擦除 Java的泛型是假泛型，是编译期的泛型 泛型信息在运⾏期完全不保留 编译器的警告 使⽤限定符List\u003c?\u003e 可以通过利⽤泛型擦除来绕过编译器检查 List并不是List的⼦类型 类⽐String/Object, String[]/Object[] 不同泛型是不同类（全新的类型） 不是相同的类（编译上），也是相同的类（字节码上） List\u003cString\u003e list=new ArrayList\u003c\u003e(); List\u003cInteger\u003e list=new ArrayList\u003c\u003e(); List\u003cInteger\u003e list=new ArrayList\u003cString\u003e(); 是错的× 但在字节码上是没有了泛型NEW java/util/ArrayList :泛型的擦除 java是假泛型 //方法 public void testObject(Fun fun){} public void testArray(Fun[] fun){} public void testList(ArrayList\u003cFun\u003e fun){} //调用 testObject(Zi zi) testArray(Zi[] zi) testList(ArrayList\u003cZi\u003e zi) //←报错 // List\u003cString\u003e并不是List\u003cObject\u003e的⼦类型 //因为泛型擦除会带来不安全，如果编译过了的话 //绕过编译器检查 ArrayList\u003cFun\u003e list=new ArrayList\u003c\u003e(); ArrayList rawList=list; rawList.add(\"\"); rawList.add(1); ArrayList\u003cZi\u003e ziList=(ArrayList\u003cZi\u003e) list; ","date":"2020-02-16","objectID":"/posts/java%E6%B3%9B%E5%9E%8B/:2:0","tags":["泛型"],"title":"Java泛型","uri":"/posts/java%E6%B3%9B%E5%9E%8B/"},{"categories":["java"],"content":"泛型的绑定 ? extends 要求泛型是某种类型及其⼦类型 ? super 要求泛型是某种类型及其⽗类型 Collections.sort ","date":"2020-02-16","objectID":"/posts/java%E6%B3%9B%E5%9E%8B/:3:0","tags":["泛型"],"title":"Java泛型","uri":"/posts/java%E6%B3%9B%E5%9E%8B/"},{"categories":["java"],"content":"类型与反射 Class RTTI（Run-Time Type Identification）运⾏时类型识别 ：不管你是当前是什么类型，总能调用getClass()获得真实类型 class：字节码，它相当于一份说明书，每当创建一个对象，有加载过按说明书创建对象，jvm会加载class文件。 静态变量本质 是属于 class jdk7：永久代 jdk8：元空间 class 对象生命周期 获取class xxx.getClass() //1 Class.forName(\"全限定类名\") //2 classloader Classloader负责从外部系统中加载⼀个类 这个类对应的Java⽂件并不⼀定需要存在 这个字节码并不⼀定需要存在（字节码本质是字节流，能在内存中） 这是Java世界丰富多彩的应⽤的基⽯ Classloader的双亲委派加载模型 （父类有加载，子类不加载，否则子类自己加载） Java语⾔规范与Java虚拟机规范 Java Language Specification JLS Java Virtual Machine Specification JVMS 这种分离提供了在JVM上运⾏其他语⾔的可能 反射 反射：通过jvm看到自己，看清自己有什么东西(看到自己说明书)。 根据参数动态生成xx： 创建实例： 1.有对应class 2.获取构造器 3.newInstance() 调用方法: 1.有对应class 2.获取方法 3.invoke() 获取属性: 1.有对应class 2.获取属性 3.get() Class c=Class.forName(\"//全限定类名\"); //getDeclaredConstructor：对应构造函数 getConstructor:public构造函数 Object object= c.getDeclaredConstructor().newInstance(); c.getMethod(\"方法名\", 参数的class ... ).invoke(该对象Object实例,参数...); c.getField(\"属性\").get(该对象Object实例); ","date":"2020-02-15","objectID":"/posts/class-and-reflect/:0:0","tags":["class","reflect"],"title":"Class and Reflect","uri":"/posts/class-and-reflect/"},{"categories":["java"],"content":"String的原理 String的原理 为什么在互联网C系列不好使，很少拿c来写后端应用 因为C和C++字符串处理很烂。 能处理好字符串是Web服务器的基本要求 Java PHP Python Ruby Perl ","date":"2020-02-14","objectID":"/posts/string%E5%8E%9F%E7%90%86/:0:0","tags":["String","StringBuffer","StringBuilder"],"title":"String原理","uri":"/posts/string%E5%8E%9F%E7%90%86/"},{"categories":["java"],"content":"字符串的不可变性 为什么字符串是不可变的？(看源代码final) 安全：线程安全，存储安全 缺点，每当修改的时候都需要重复创建新的对象 扩展：存储安全 hash 约定 二个对象相等必须返回hashcode是一样的 在整一个java生命周期必须返回一样hashcode 因此需要的对象是不可变 ","date":"2020-02-14","objectID":"/posts/string%E5%8E%9F%E7%90%86/:1:0","tags":["String","StringBuffer","StringBuilder"],"title":"String原理","uri":"/posts/string%E5%8E%9F%E7%90%86/"},{"categories":["java"],"content":"想修改怎么办 StringBuilder(优先使⽤，线程不安全，速度快) StringBuffer(线程安全，速度相对较慢) ","date":"2020-02-14","objectID":"/posts/string%E5%8E%9F%E7%90%86/:2:0","tags":["String","StringBuffer","StringBuilder"],"title":"String原理","uri":"/posts/string%E5%8E%9F%E7%90%86/"},{"categories":["java"],"content":"字符串与编码 字符 -\u003e 字节 (编码) 字节 -\u003e 字符 (解码) ","date":"2020-02-14","objectID":"/posts/string%E5%8E%9F%E7%90%86/:3:0","tags":["String","StringBuffer","StringBuilder"],"title":"String原理","uri":"/posts/string%E5%8E%9F%E7%90%86/"},{"categories":["java"],"content":"字符集 ：Uoicode 字符集：相当于一个字典 码点(code point)：字典里面要找的字 存所有语言，int是最符合Uoicode存储 因此每一个字符都要4byte，这样太浪费了 BOM （字节顺序标记：ByteOrderMark） 每个数字代表⼀个字符，叫做“码点”（code point） 最常⻅的两种编码⽅案： UTF-16：Java程序内部的存储⽅法 UTF-8 Mac/Linux默认编码是UTF-8 Windows默认的中⽂编码是GBK(时间问题，windows比UTF-8早) 如果没有意外，把你所有的编码⽅案都改成UTF-8 ","date":"2020-02-14","objectID":"/posts/string%E5%8E%9F%E7%90%86/:4:0","tags":["String","StringBuffer","StringBuilder"],"title":"String原理","uri":"/posts/string%E5%8E%9F%E7%90%86/"},{"categories":["java"],"content":"选择字符集 //用jdk7 NIO举例子 Files.readAllLines(file.toPath(), Charset.forName(\"GBK\")); //例子 InputStreamReader(InputStream in, CharsetDecoder dec) new InputStreamReader( new FileInputStream(file) , \"UTF-8\"); ","date":"2020-02-14","objectID":"/posts/string%E5%8E%9F%E7%90%86/:5:0","tags":["String","StringBuffer","StringBuilder"],"title":"String原理","uri":"/posts/string%E5%8E%9F%E7%90%86/"},{"categories":["java"],"content":"如果出现乱码 文件是什么编码 读到计算机是什么编码 输出是什么编码 ","date":"2020-02-14","objectID":"/posts/string%E5%8E%9F%E7%90%86/:6:0","tags":["String","StringBuffer","StringBuilder"],"title":"String原理","uri":"/posts/string%E5%8E%9F%E7%90%86/"},{"categories":["算法与数据结构"],"content":"算法：查找、排序、遍历（它们分别时间复杂度？) 数据结构：数组、链表、栈、队列、哈希表、树（它们的插入、删除和查找时间？） 数据结构 ","date":"2020-02-13","objectID":"/posts/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:0:0","tags":["算法","数据结构"],"title":"算法与数据结构","uri":"/posts/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["算法与数据结构"],"content":"数组 随机寻址 常数时间 插⼊/删除 线性时间 查找 ⽆序：线性时间 有序：对数时间（⼆分查找） ","date":"2020-02-13","objectID":"/posts/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:1:0","tags":["算法","数据结构"],"title":"算法与数据结构","uri":"/posts/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["算法与数据结构"],"content":"链表 寻址 线性时间 插⼊/删除 常数时间 查找 线性时间 手写 翻转链表（递归） 判断链表是否成环 ","date":"2020-02-13","objectID":"/posts/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:2:0","tags":["算法","数据结构"],"title":"算法与数据结构","uri":"/posts/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["算法与数据结构"],"content":"栈 Stack FILO （First In Last Out） 应⽤：⽅法栈 实现用数组 ","date":"2020-02-13","objectID":"/posts/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:3:0","tags":["算法","数据结构"],"title":"算法与数据结构","uri":"/posts/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["算法与数据结构"],"content":"队列 Queue FIFO （First In First Out） 应⽤：线程池 实现用数组 ","date":"2020-02-13","objectID":"/posts/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:4:0","tags":["算法","数据结构"],"title":"算法与数据结构","uri":"/posts/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["算法与数据结构"],"content":"哈希表 查找/插⼊/删除操作都是O(1) 哈希算法与碰撞（int类型42亿，数据不止42亿） 哈希桶的内部实现 hashCode()是不可逆 想想和HashMap问题，java8 java7的hashMap： 数组+链表 java8的hashMap： 数组+链表/红黑树 hashMap的哈希桶为什么是2的n次方？ 因为要快速拿到数组下标（2的n-1 \u0026\u0026 hashCode ） 能分布均匀 ","date":"2020-02-13","objectID":"/posts/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:5:0","tags":["算法","数据结构"],"title":"算法与数据结构","uri":"/posts/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["算法与数据结构"],"content":"⼆叉树 ⼆叉树有两个孩⼦ 相应的，多叉树有多个孩⼦ ","date":"2020-02-13","objectID":"/posts/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:6:0","tags":["算法","数据结构"],"title":"算法与数据结构","uri":"/posts/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["算法与数据结构"],"content":"搜索⼆叉树 ⼀棵经过精⼼设计的⼆叉树 可以将搜索效率降低到对数时间 致命缺点：可能会退化成链表 红⿊树 算法 ","date":"2020-02-13","objectID":"/posts/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:7:0","tags":["算法","数据结构"],"title":"算法与数据结构","uri":"/posts/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["算法与数据结构"],"content":"binarySearch 在jdk有自带的binarySearch可以参考如何自己手写代码 public static int binarySearch(String[] strings, String target) { int low = 0; int high = strings.length - 1; while (low \u003c= high) { int mid = low + high \u003e\u003e\u003e 1; String midVal = strings[mid]; if (midVal.compareTo(target) \u003c 0) { low = mid + 1; } else { if (midVal.compareTo(target) == 0) { return mid; } high = mid - 1; } } return -1; } ","date":"2020-02-13","objectID":"/posts/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:8:0","tags":["算法","数据结构"],"title":"算法与数据结构","uri":"/posts/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["算法与数据结构"],"content":"遍历 深度优先遍历 dfs（栈来实现） 先序遍历：根结点 → 左子树 → 右子树 中序遍历：左子树 → 根结点 → 右子树 后序遍历：左子树 → 右子树 → 根结点 广度优先遍历 bfs（队列来实现） //队列次序： 1 32 543 7654 // 请实现二叉树的广度优先遍历（层次遍历） public static List\u003cInteger\u003e bfs(TreeNode root) { if(root==null){ throw new RuntimeException(\"empty tree\"); } List\u003cInteger\u003e result = new ArrayList\u003c\u003e(); ArrayDeque\u003cTreeNode\u003e queue = new ArrayDeque\u003c\u003e(); queue.addLast(root); while (!queue.isEmpty()) { TreeNode currentNode = queue.removeFirst(); result.add(currentNode.value); if (currentNode.left != null) { queue.addLast(currentNode.left); } if (currentNode.right != null) { queue.addLast(currentNode.right); } } return result; } // 请实现二叉树的深度优先遍历（前序） public static List\u003cInteger\u003e dfs(TreeNode root) { List\u003cInteger\u003e result = new ArrayList\u003c\u003e(); ArrayDeque\u003cTreeNode\u003e stack = new ArrayDeque\u003c\u003e(); stack.push(root); while (!stack.isEmpty()) { TreeNode currentNode = stack.pop(); result.add(currentNode.value); if (currentNode.right != null) { stack.push(currentNode.right); } if (currentNode.left != null) { stack.push(currentNode.left); } } return result; } ","date":"2020-02-13","objectID":"/posts/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:9:0","tags":["算法","数据结构"],"title":"算法与数据结构","uri":"/posts/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["算法与数据结构"],"content":"排序 下列都是平均时间复杂度 插入排序 O(N2) 选择排序 O(N2) 冒泡排序 O(N2) 快速排序 O(N*log2N) 归并排序 O(N*log2N) 堆排序 O(N*log2N) // 选择排序 // 按照从小到大排序 public static void sort1(int[] array) { for (int i = 0; i \u003c array.length; i++) { int minIndex = i; for (int j = i + 1; j \u003c array.length; j++) { if (array[j] \u003c array[minIndex]) { minIndex = j; } } if (minIndex != i) { int temp = array[i]; array[i] = array[minIndex]; array[minIndex] = temp; } } } // 冒泡排序 // 按照从小到大排序 public static void bubbleSort(int[] array) { for (int i = 0; i \u003c array.length; i++) { int temp; for (int j = 0; j \u003c array.length - 1 - i; j++) { if (array[j] \u003e array[j + 1]) { temp = array[j]; array[j] = array[j + 1]; array[j + 1] = temp; } } } } // 插入排序 // 按照从小到大排序 public static void insertion_sort(int[] array) { for (int i = 1; i \u003c array.length; i++) { int key = array[i]; int j = i - 1; while (j \u003e= 0 \u0026\u0026 array[j] \u003e key) { array[j + 1] = array[j]; j--; } array[j + 1] = key; } } // 快速排序 // 按照从小到大排序 //arr数组、head头下标、tail尾下标 public static void qSort(int[] arr, int head, int tail) { if (head \u003e= tail || arr == null || arr.length \u003c= 1) { return; } int i = head, j = tail, pivot = arr[(head + tail) / 2]; while (i \u003c= j) { while (arr[i] \u003c pivot) { ++i; } while (arr[j] \u003e pivot) { --j; } if (i \u003c j) { int t = arr[i]; arr[i] = arr[j]; arr[j] = t; ++i; --j; } else if (i == j) { ++i; } } qSort(arr, head, j); qSort(arr, i, tail); } ","date":"2020-02-13","objectID":"/posts/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:10:0","tags":["算法","数据结构"],"title":"算法与数据结构","uri":"/posts/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["java"],"content":"精髓：数据变换，简化代码 Stream简化代码，熟练能让你用得很爽 Stream Stream的API-创建Stream Collection.stream() Stream.of String.chars() IntSteam.range() Stream的API-中间操作 仍然返回Stream的操作 filter map 对流操作，返回新的流（映射） sorted Stream的API-终结操作 返回⾮Stream的操作，包括void ⼀个流只能被消费⼀次 forEach count/max/min findFirst/findAny anyMatch/noneMatch ⭐collect collector与Collectors collect操作是最强⼤的操作 toSet/toList/toCollection joining() toMap() groupingBy() ","date":"2020-02-12","objectID":"/posts/java8_stream/:0:0","tags":["java8","Stream"],"title":"Java8_Stream","uri":"/posts/java8_stream/"},{"categories":["java"],"content":"并发流 parallelStream() 可以通过并发提⾼互相独⽴的操作的性能 在正确使⽤的前提下，可以获得近似线性的性能提升 但是！使⽤要⼩⼼，性能要测试，如果你不知道⾃⼰在做什么，就忘了它吧 ","date":"2020-02-12","objectID":"/posts/java8_stream/:1:0","tags":["java8","Stream"],"title":"Java8_Stream","uri":"/posts/java8_stream/"},{"categories":["java"],"content":"学习java8函数式编程 Java8函数式编程 用java8的函数式编程来简化自己的代码 lambda表达式、方法引用和实例方法应用 自动转换成函数接口 如何使用函数式编程 简单来说就是： 函数的返回值类型要相同 参数的类型要相同 ","date":"2020-02-11","objectID":"/posts/java8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/:0:0","tags":["java8","函数式编程"],"title":"Java8函数式编程","uri":"/posts/java8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"categories":["java"],"content":"几种类型 有 → 有 predicate (T → boolean) funtion (T → R) 有 → 无 Consumer (T → System.out.println(“x”);) 无 → 有 Supplier (() → new Object) public class User{ private String name; public String getName() {return name;} public void judgeName(Predicate preadicate){} public static void main(String[] args){ judgeName(user-\u003euser.getName.equals(\"sqc\")); judgeName(new Predicate\u003cUser\u003e{ @Override public boolean test(User user){ return user.getName.equals(\"sqc\"); } }); } } ","date":"2020-02-11","objectID":"/posts/java8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/:1:0","tags":["java8","函数式编程"],"title":"Java8函数式编程","uri":"/posts/java8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"categories":["java"],"content":"lambda表达式 任何只包含一个抽象方法的接口都可以被自动转换为函数接口 lambda表达式会变成一个static方法 完整的lambda表达式(User user)-\u003e{//方法体} 你不加类型(User)也行 会帮你根据上下文匹配对应类型 ","date":"2020-02-11","objectID":"/posts/java8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/:2:0","tags":["java8","函数式编程"],"title":"Java8函数式编程","uri":"/posts/java8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"categories":["java"],"content":"方法引用 静态方法引用 实例方法引用 //静态方法引用 public static void xxx(String str){} //引用方式 User::xxx //实例方法引用 public void xxx(){} //传参数会 传本类 this //引用方式 User::xxx ","date":"2020-02-11","objectID":"/posts/java8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/:3:0","tags":["java8","函数式编程"],"title":"Java8函数式编程","uri":"/posts/java8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"categories":["java"],"content":"Comparator comparing() 比较 reverse() 相反 thenComparing() 再比较 ","date":"2020-02-11","objectID":"/posts/java8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/:4:0","tags":["java8","函数式编程"],"title":"Java8函数式编程","uri":"/posts/java8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"categories":["java","问题"],"content":"如何解决java进程的死锁问题 解决java死锁 查看java进程状态 ：jps 打印java所有栈信息 ：jstack ASUS@DESKTOP-OKRCSJG MINGW64 xxx (master) $ jps # 查看java ps(process status) ","date":"2020-02-02","objectID":"/posts/%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81/:0:0","tags":["死锁"],"title":"解决死锁","uri":"/posts/%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81/"},{"categories":["Hugo"],"content":"github和域名绑定教程 域名与博客绑定配置 就有博客拉 Hugo创建一个公开的文件public，记得要.gitignore添加public不然冲突 创建Git仓库自己上面的知识点 有3个步骤1.创建2.添加3.提交 与远程仓库绑定 有2个步骤 1.记得是ssh 2.pull 在远程仓库的settings上，加入你买的域名 记得要选master和测试的话不要https 配置DNS a记录 4条github上有指定的a记录 然后git bash上nslookup “买的域名” 这是windows命令，然后等 ","date":"2020-02-01","objectID":"/posts/%E5%9F%9F%E5%90%8D%E4%B8%8E%E5%8D%9A%E5%AE%A2%E7%BB%91%E5%AE%9A%E9%85%8D%E7%BD%AE/:0:0","tags":["域名","博客"],"title":"域名与博客绑定配置","uri":"/posts/%E5%9F%9F%E5%90%8D%E4%B8%8E%E5%8D%9A%E5%AE%A2%E7%BB%91%E5%AE%9A%E9%85%8D%E7%BD%AE/"},{"categories":["Hugo"],"content":"我遇到的问题： 阿里云那坑爹 不是及时同步，我买了域名但还是要过很久才能域名和我绑定 Hugo的更新问题 在config改默认域名 我的theme：dream很坑没有详细说明，要我自己找’i18n’改博客名 ","date":"2020-02-01","objectID":"/posts/%E5%9F%9F%E5%90%8D%E4%B8%8E%E5%8D%9A%E5%AE%A2%E7%BB%91%E5%AE%9A%E9%85%8D%E7%BD%AE/:1:0","tags":["域名","博客"],"title":"域名与博客绑定配置","uri":"/posts/%E5%9F%9F%E5%90%8D%E4%B8%8E%E5%8D%9A%E5%AE%A2%E7%BB%91%E5%AE%9A%E9%85%8D%E7%BD%AE/"},{"categories":["git"],"content":"git的本地和远程仓库的有关命令 学习git命令行 ","date":"2020-02-01","objectID":"/posts/git%E6%9C%AC%E5%9C%B0%E5%92%8C%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4/:0:0","tags":["git命令"],"title":"git本地和远程命令","uri":"/posts/git%E6%9C%AC%E5%9C%B0%E5%92%8C%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4/"},{"categories":["git"],"content":"git命令（本地） 用git前要配置好 git config --global user.name 你的英文名 git config --global user.email 你的邮箱 git config --global push.default simple git config --global core.quotepath false git config --global core.editor \"code --wait\" git config --global core.autocrlf input 注意：上面的英文名和邮箱跟 GitHub 没有关系。 上面的设置是默认vscode，你自己也可以设置与git相关的软件 git config --global --list 查看配置如何 Git init 创建名叫.git本地仓库（注意要看当前路径，不然设错路径文件很大） Git add 文件名 (或者当前路径’ . ’) 添加准备commit的状态 Git status 顾名思义看状态 Git commit –m 字符串（提交的理由） Git commit –v详细看修改哪些地方，然后在第一行家提交理由 打开vscode（自己之前设置打开的软件，可选的） Git log 查看当前.git仓库之前的版本 Git reset --hard xxx 回退到xxx版本（之前commit过有记录版本号用git log） Git reflog 查看全部的版本号可以查看所有分支的所有操作记录（包括已经被删除的 commit 记录和 reset 的操作） Git branch 分支名 创建分支 Git branch –d 分支名 删除分支 Git checkout 分支名 切换分支 Git merge xxx 将xxx分支合并到当前分支(很多时候回发生冲突) ","date":"2020-02-01","objectID":"/posts/git%E6%9C%AC%E5%9C%B0%E5%92%8C%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4/:1:0","tags":["git命令"],"title":"git本地和远程命令","uri":"/posts/git%E6%9C%AC%E5%9C%B0%E5%92%8C%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4/"},{"categories":["git"],"content":"git远程命令（ssh绑定） ","date":"2020-02-01","objectID":"/posts/git%E6%9C%AC%E5%9C%B0%E5%92%8C%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4/:2:0","tags":["git命令"],"title":"git本地和远程命令","uri":"/posts/git%E6%9C%AC%E5%9C%B0%E5%92%8C%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4/"},{"categories":["git"],"content":"我的第一次生成钥匙（一个私钥id_res 一个公钥id_res.pub） ","date":"2020-02-01","objectID":"/posts/git%E6%9C%AC%E5%9C%B0%E5%92%8C%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4/:2:1","tags":["git命令"],"title":"git本地和远程命令","uri":"/posts/git%E6%9C%AC%E5%9C%B0%E5%92%8C%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4/"},{"categories":["git"],"content":"生成完在github上设置自己的公钥 ","date":"2020-02-01","objectID":"/posts/git%E6%9C%AC%E5%9C%B0%E5%92%8C%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4/:2:2","tags":["git命令"],"title":"git本地和远程命令","uri":"/posts/git%E6%9C%AC%E5%9C%B0%E5%92%8C%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4/"},{"categories":["git"],"content":"在git bash上验证 ssh -T git@github.com 然后github会给自己一个公钥证明自己是github官网 输出是 HI 自己的github名 就绑定成功 ","date":"2020-02-01","objectID":"/posts/git%E6%9C%AC%E5%9C%B0%E5%92%8C%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4/:2:3","tags":["git命令"],"title":"git本地和远程命令","uri":"/posts/git%E6%9C%AC%E5%9C%B0%E5%92%8C%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4/"},{"categories":["git"],"content":"Git Push（Pull更新之后在push） 开始上传本地仓库，没有就要（看回git本地命令了） 上传命令（ssh） git remote add origin git@github.com:spclock/first_Demo.git git 远程的意思 add origin git@github.com:git账号名/开源的项目名 如何已经有origin，怎么改 Git remote set-url origin git@github.com:git账号名/开源的项目名 git push -u origin master（分支的名字） -u 如果再有push就执行上次那一个分支（直接git push） 如果你要换分支要重新打一次命令改参数 ","date":"2020-02-01","objectID":"/posts/git%E6%9C%AC%E5%9C%B0%E5%92%8C%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4/:2:4","tags":["git命令"],"title":"git本地和远程命令","uri":"/posts/git%E6%9C%AC%E5%9C%B0%E5%92%8C%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4/"},{"categories":["git"],"content":"Git clone:复制github上的链接 ","date":"2020-02-01","objectID":"/posts/git%E6%9C%AC%E5%9C%B0%E5%92%8C%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4/:2:5","tags":["git命令"],"title":"git本地和远程命令","uri":"/posts/git%E6%9C%AC%E5%9C%B0%E5%92%8C%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4/"},{"categories":["git"],"content":"Git Pull（更新代码） 每次开始前都要git pull更新一下代码 ","date":"2020-02-01","objectID":"/posts/git%E6%9C%AC%E5%9C%B0%E5%92%8C%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4/:2:6","tags":["git命令"],"title":"git本地和远程命令","uri":"/posts/git%E6%9C%AC%E5%9C%B0%E5%92%8C%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4/"},{"categories":["java"],"content":"死锁排查，线程安全，生产者消费者，线程池，按自己想法调度线程。 静态和非静态同步方法锁问题。 线程安全(同步) 生产者消费者 wait/notify/notifyAll代码 lockcondition代码 blockingqueue代码 线程安全(同步) synchronirzed(① 方法函数上加synchronirzed，② 用的锁是this) 静态同步方法锁：this.getClass() 非静态同步方法锁：实例对象 ReentrantLock(按synchronirzed撸出来的代码) Lock代替synchronirzed （用完记得一定要finally{lock.unlock()}） Condition代替Object监视器方法的使用 java.util.concurrent（JUC） AtomicInteger （原子操作） 类不可变 Integer/String //synchronized的二种形式 public synchronized int addAndGet(int i) { } //形式1 public int addAndGet(int i) { synchronized(this){方法体}//形式2 } //1. synchronirzed(用的锁是this) public class Counter { private int value = 0; public int getValue() { return value; } // 加上一个整数i，并返回加之后的结果 public synchronized int addAndGet(int i) { value += i; return value; } // 减去一个整数i，并返回减之后的结果 public synchronized int minusAndGet(int i) { value -= i; return value; } } //2. java.util.concurrent（JUC） import java.util.concurrent.locks.ReentrantLock; public class Counter { ReentrantLock lock = new ReentrantLock(); private int value = 0; public int getValue() { return value; } // 加上一个整数i，并返回加之后的结果 public int addAndGet(int i) { try{ lock.lock(); value += i; return value; }finally{ lock.unlock(); } } // 减去一个整数i，并返回减之后的结果 public int minusAndGet(int i) { try{ lock.lock(); value -= i; return value; }finally{ lock.unlock(); } } } //3. AtomicInteger （原子操作） import java.util.concurrent.atomic.AtomicInteger; public class Counter { private static AtomicInteger value = new AtomicInteger(0); public int getValue() { return value.get(); } // 加上一个整数i，并返回加之后的结果 public int addAndGet(int i) { return value.addAndGet(i); } // 减去一个整数i，并返回减之后的结果 public int minusAndGet(int i) { return value.addAndGet(-i); } } 生产者消费者 虽然已经解决了多线程公共变量问题，但都是cpu全部决定如何调度线程 按自己想法调度线程 用一下几种方法： wait/notify/notifyAll Lock/Condition BlockingQueue Semaphore Exchanger 等等 如果出现了IllegalMonitorStateException 就是没带监视器，或者你用错了别的监视器 ","date":"2020-01-30","objectID":"/posts/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8or%E5%90%8C%E6%AD%A5/:0:0","tags":["thread","死锁","线程安全","同步"],"title":"线程安全or同步","uri":"/posts/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8or%E5%90%8C%E6%AD%A5/"},{"categories":["java"],"content":"wait/notify/notifyAll //wait/notify/notifyAll方法 import java.util.Random; public class ProducerConsumer1 { private static Integer random; public static void main(String[] args) throws InterruptedException { Object lock = new Object(); Producer producer = new Producer(lock); Consumer consumer = new Consumer(lock); producer.start(); consumer.start(); producer.join(); producer.join(); } public static class Producer extends Thread { final Object lock; public Producer(Object lock) { this.lock = lock; } @Override public void run() { for (int i = 0; i \u003c 10; i++) { synchronized (lock) { while (random != null) { try { lock.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } random = new Random().nextInt(); System.out.println(\"Producing \" + random); lock.notify(); } } } } public static class Consumer extends Thread { final Object lock; public Consumer(Object lock) { this.lock = lock; } @Override public void run() { for (int i = 0; i \u003c 10; i++) { synchronized (lock) { while (random == null) { try { lock.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(\"Consuming \" + random); random = null; lock.notify(); } } } } } ","date":"2020-01-30","objectID":"/posts/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8or%E5%90%8C%E6%AD%A5/:0:1","tags":["thread","死锁","线程安全","同步"],"title":"线程安全or同步","uri":"/posts/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8or%E5%90%8C%E6%AD%A5/"},{"categories":["java"],"content":"Lock/Condition //Lock/Condition import java.util.Random; import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.ReentrantLock; public class ProducerConsumer2 { private static Integer random; public static void main(String[] args) throws InterruptedException { ReentrantLock lock = new ReentrantLock(); Condition condition = lock.newCondition(); Producer producer = new Producer(lock, condition); Consumer consumer = new Consumer(lock, condition); producer.start(); consumer.start(); producer.join(); producer.join(); } public static class Producer extends Thread { ReentrantLock lock; Condition condition; public Producer(ReentrantLock lock, Condition condition) { this.lock = lock; this.condition = condition; } @Override public void run() { for (int i = 0; i \u003c 10; i++) { try { lock.lock(); while (random != null) { try { condition.await(); } catch (InterruptedException e) { e.printStackTrace(); } } random = new Random().nextInt(); System.out.println(\"Producing \" + random); condition.signal(); } finally { lock.unlock(); } } } } public static class Consumer extends Thread { ReentrantLock lock; Condition condition; public Consumer(ReentrantLock lock, Condition condition) { this.lock = lock; this.condition = condition; } @Override public void run() { for (int i = 0; i \u003c 10; i++) { try { lock.lock(); while (random == null) { try { condition.await(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(\"Consuming \" + random); random = null; condition.signal(); } finally { lock.unlock(); } } } } } ","date":"2020-01-30","objectID":"/posts/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8or%E5%90%8C%E6%AD%A5/:0:2","tags":["thread","死锁","线程安全","同步"],"title":"线程安全or同步","uri":"/posts/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8or%E5%90%8C%E6%AD%A5/"},{"categories":["java"],"content":"BlockingQueue //BlockingQueue import java.util.Random; import java.util.concurrent.BlockingQueue; import java.util.concurrent.LinkedBlockingQueue; public class ProducerConsumer3 { public static void main(String[] args) throws InterruptedException { BlockingQueue\u003cInteger\u003e queue = new LinkedBlockingQueue\u003c\u003e(1); BlockingQueue\u003cInteger\u003e signal = new LinkedBlockingQueue\u003c\u003e(1); Producer producer = new Producer(queue, signal); Consumer consumer = new Consumer(queue, signal); producer.start(); consumer.start(); producer.join(); producer.join(); } public static class Producer extends Thread { BlockingQueue\u003cInteger\u003e queue; BlockingQueue\u003cInteger\u003e signal; public Producer(BlockingQueue\u003cInteger\u003e queue, BlockingQueue\u003cInteger\u003e signal) { this.queue = queue; this.signal = signal; } @Override public void run() { for (int i = 0; i \u003c 10; i++) { int random = new Random().nextInt(); System.out.println(\"Producing \" + random); try { queue.put(random); signal.take(); } catch (InterruptedException e) { e.printStackTrace(); } } } } public static class Consumer extends Thread { BlockingQueue\u003cInteger\u003e queue; BlockingQueue\u003cInteger\u003e signal; public Consumer(BlockingQueue\u003cInteger\u003e queue, BlockingQueue\u003cInteger\u003e signal) { this.queue = queue; this.signal = signal; } @Override public void run() { for (int i = 0; i \u003c 10; i++) { try { System.out.println(\"Consuming \" + queue.take()); signal.put(0); } catch (InterruptedException e) { e.printStackTrace(); } } } } } ","date":"2020-01-30","objectID":"/posts/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8or%E5%90%8C%E6%AD%A5/:0:3","tags":["thread","死锁","线程安全","同步"],"title":"线程安全or同步","uri":"/posts/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8or%E5%90%8C%E6%AD%A5/"},{"categories":["java"],"content":"什么是进程、线程和多线程，怎么用和有什么用，需要注意什么。不会就给我看 进程、线程和任务概念 ","date":"2020-01-29","objectID":"/posts/thread/:0:0","tags":["多线程","Thread"],"title":"Thread","uri":"/posts/thread/"},{"categories":["java"],"content":"1.进程 **进程(Process)**是计算机中已运行程序的实体。进程本身不会运行，是线程的容器。程序本身只是指令的集合，进程才是程序(那些指令)的真正运行。若干进程有可能与同一个程序相关系，且每个进程皆可以同步(循序)或不同步(平行)的方式独立运行。进程为现今分时系统的基本运作单位。 ","date":"2020-01-29","objectID":"/posts/thread/:1:0","tags":["多线程","Thread"],"title":"Thread","uri":"/posts/thread/"},{"categories":["java"],"content":"2.线程 **线程(thread)**是操作系统能够进行运算调度的最小单位。它被包涵在进程之中。 单线程：一条线程指的是进程中一个单一顺序的控制流。 多线程：一个进程中可以并发多个线程，每条线程并行执行不同的任务。 在Unix System V及SunOS中也被称为轻量进程(lightweight processes)，但轻量进程更多指内核线程(kernel thread)，而把用户线程(user thread)称为线程。 ","date":"2020-01-29","objectID":"/posts/thread/:2:0","tags":["多线程","Thread"],"title":"Thread","uri":"/posts/thread/"},{"categories":["java"],"content":"线程状态 初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。 运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。 阻塞(BLOCKED)：表示线程阻塞于锁。 等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。 超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。 终止(TERMINATED)：表示该线程已经执行完毕。 深入了解线程状态 ","date":"2020-01-29","objectID":"/posts/thread/:2:1","tags":["多线程","Thread"],"title":"Thread","uri":"/posts/thread/"},{"categories":["java"],"content":"多线程 Java中只有这么⼀种东⻄代表线程：Thread start⽅法才能并发执⾏！ 每多开⼀个线程，就多⼀个执⾏流 ⽅法栈(局部变量)是线程私有的 静态变量/类变量是被所有线程共享的 //创建一个线程第一种方法 class MyThread extends Thread{ @Override public void run() { //多线程的任务 } public static void main(String[] args) { MyThread thread=new MyThread(); } } //第二种方法 Thread thread=new Thread(任务); //任务可以是Runnable的匿名内部类 ","date":"2020-01-29","objectID":"/posts/thread/:2:2","tags":["多线程","Thread"],"title":"Thread","uri":"/posts/thread/"},{"categories":["java"],"content":"3.任务 **任务（task）**是最抽象的，是一个一般性的术语，指由软件完成的一个活动。一个任务既可以是一个进程，也可以是一个线程。简言之，它指的是一系列共同达到某一目的的操作。 Runnable —— Thread 不能返回值，没有异常抛出 Callable —— Future 能返回值，有异常抛出 FutureTask 问题 ","date":"2020-01-29","objectID":"/posts/thread/:3:0","tags":["多线程","Thread"],"title":"Thread","uri":"/posts/thread/"},{"categories":["java"],"content":"为什么要用多线程 因为要并发，cpu 太快了太闲了，需要合理使用时间片 java程序是同步/阻塞的 ","date":"2020-01-29","objectID":"/posts/thread/:4:0","tags":["多线程","Thread"],"title":"Thread","uri":"/posts/thread/"},{"categories":["java"],"content":"什么时候使用多线程 IO密集型 √（例：文件和网络） cpu密集型 X (cpu不闲了你还给这么多活干?) ","date":"2020-01-29","objectID":"/posts/thread/:5:0","tags":["多线程","Thread"],"title":"Thread","uri":"/posts/thread/"},{"categories":["java"],"content":"使用多线程需要注意什么 共享变量 (安全隐患) 每一个线程里面的变量都是私有的 ","date":"2020-01-29","objectID":"/posts/thread/:6:0","tags":["多线程","Thread"],"title":"Thread","uri":"/posts/thread/"},{"categories":null,"content":"Hi, my name is Su Pu Cheng. This is my blog. ","date":"2020-01-23","objectID":"/about/desc/:0:0","tags":null,"title":"SuPuCheng","uri":"/about/desc/"},{"categories":["java"],"content":"有关数据库和sql的语法知识 数据库 SQL语法 databases use database_name create table table_name alter table table_name drop tabel table_name tables insert into delete select limit 从第几个,取多少个 join (inner默认、left、right….) order by 排序 （默认desc降序） group by 分组 update 用join的时候要注意 多嵌套 join 搞清楚哪一个和哪一个的交集 ","date":"2020-01-23","objectID":"/posts/sql/:0:0","tags":["数据库","sql"],"title":"SQL","uri":"/posts/sql/"},{"categories":["java"],"content":"使⽤JDBC访问数据库 Java Database Connection 连接串url、⽤户名user、密码passage Statement PrepareStatement - 防SQL注⼊的 （AST 树的型式） SQL注⼊是因为SQL没有验证传⼊的参数 导致攻击者可以通过精⼼设计的参数使得拼装出的SQL达 到他的⽬的 ResultSet 用完一定要释放close() Docker docker就是一个微型的linux 本地安装数据库会很麻烦（更新什么的）特别是windows 百分百兼容、百分百⽆残留、百分百统⼀、⽅便 现在我们启动的数据库的数据是不持久化的 除⾮在启动容器的时候使⽤-v参数 提速下镜像 docker cn reistry-mirror 因为docker是数据存内存，因此你要映射 映射端口，映射文件路径 ","date":"2020-01-23","objectID":"/posts/sql/:1:0","tags":["数据库","sql"],"title":"SQL","uri":"/posts/sql/"},{"categories":["java"],"content":"Cut out summary from your post content here. 异常体系图 异常就是继承了Throwable checked Exception 受检异常 throwable Exception （代表⼀种预料之中的异常） unchecked Exception 不受检异常 runtimeException （代表⼀种预料之外的异常） error catch的级联与合并 throw抛出⼀个异常（一定有错） throws只是⼀个声明（可能有错） 异常的处理 ","date":"2020-01-22","objectID":"/posts/%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/:0:0","tags":["Exception","handle Exception"],"title":"异常体系","uri":"/posts/%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/"},{"categories":["java"],"content":"1.抛出异常 throws ","date":"2020-01-22","objectID":"/posts/%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/:1:0","tags":["Exception","handle Exception"],"title":"异常体系","uri":"/posts/%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/"},{"categories":["java"],"content":"异常的抛出原则 能⽤if/else处理的，不要使⽤异常 尽早抛出异常 异常要准确、带有详细信息 抛出异常也⽐悄悄地执⾏错误的逻辑强的多 ","date":"2020-01-22","objectID":"/posts/%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/:1:1","tags":["Exception","handle Exception"],"title":"异常体系","uri":"/posts/%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/"},{"categories":["java"],"content":"2.try/catch/finally ","date":"2020-01-22","objectID":"/posts/%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/:2:0","tags":["Exception","handle Exception"],"title":"异常体系","uri":"/posts/%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/"},{"categories":["java"],"content":"异常的处理原则 本⽅法是否有责任处理这个异常？ 不要处理不归⾃⼰管的异常 本⽅法是否有能⼒处理这个异常？ 如果⾃⼰⽆法处理，就抛出 如⾮万分必要，不要忽略异常 ","date":"2020-01-22","objectID":"/posts/%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/:2:1","tags":["Exception","handle Exception"],"title":"异常体系","uri":"/posts/%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/"},{"categories":["java"],"content":"用途功能 如果没有try，异常将击穿所有的栈帧（异常会被一直往外抛） catch可以将⼀个异常抓住 //处理例子 catch(Exception e){ //处理异常 //在日志里打印异常 //返回对应的对异常的处理 } finally执⾏清理⼯作 （finally再return） JDK7+：try-with-resources 语法糖 实现AutoCloseable 限制只能在同一个方法中被调用（例子：业务要在某一地方打开，另一个地方关闭）用file leak detector ","date":"2020-01-22","objectID":"/posts/%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/:2:2","tags":["Exception","handle Exception"],"title":"异常体系","uri":"/posts/%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/"},{"categories":["java"],"content":"异常的排查 Throwable 栈轨迹 Stacktrace （排查问题最重要的信息，没有之⼀） 异常链（Caused by）就是嵌套了try ","date":"2020-01-22","objectID":"/posts/%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/:3:0","tags":["Exception","handle Exception"],"title":"异常体系","uri":"/posts/%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/"},{"categories":["java"],"content":"Cut out summary from your post content here. io体系 inputStream 字节输入流 outputStream 字节输出流 Reader 字符输入流 解码 Writer 字符输出流 编码 Buffer 缓冲区 ⼀切⽂件的本质 ⼀段字节流： ⽂本⽂件（txt/代码/HTML等） ⼆进制⽂件 每个程序负责解释⽂件中的字节流 mp4，html，class，avi 都是一段字节流，每个程序都有不同解析。 ⽂件写⼊字节流 从⽹络读取字节流 从其他什么破烂玩意读取字节流 如果你不是对⽂件系统⼗分熟悉的话，请永远使⽤绝对路 径！！！ File 不要误会！不要误会！不要误会！ File并不代表⼀个“⽂件”，它只代表⼀个“路径” 抽象的“⽂件”路径：⽂件或者⽂件夹 File的常⻅⽅法 绝对路径与相对路径 读/写⽂件 NIO （Java 7+） Non-blocking I/O，在Java领域，也称为New I/O（与多线程有关） NIO的Path - 就是旧版本的File （有互相转换的方法） 经典的IO模型基于流的（就意味着一个一个字节的传） 优点：容易理解，方便抽象（方便抽象：能处理文件、网络和其他） 缺点：慢！！！ ","date":"2020-01-22","objectID":"/posts/file%E4%B8%8Eio/:0:0","tags":["file","io体系"],"title":"File与io","uri":"/posts/file%E4%B8%8Eio/"},{"categories":["java"],"content":"NIO 基本数据模型：块 NIO处理：1. 缓冲buffer 或 cache 2. 并发 ","date":"2020-01-22","objectID":"/posts/file%E4%B8%8Eio/:1:0","tags":["file","io体系"],"title":"File与io","uri":"/posts/file%E4%B8%8Eio/"},{"categories":["计算机网络"],"content":"OSI和TCP / IP都是最受欢迎和使用最广泛的通信网络协议。它们之间的主要区别在于OSI是一种概念模型，实际上并未用于通信。它定义了如何在网络或不同体系结构中传输数据。而TCP / IP被广泛用于链路的建立和网络互动。TCP / IP还仅允许在网络层上使用连接模式，但是这两种方法都在传输层上。使用OSI模型，它可以促进无连接和面向连接的网络通信，但是面向连接的通信仅在传输层中被允许。 OSI模型 在OSI模型是一个概念模型由国际标准化组织，它允许各种通信系统通过标准的协议进行通信的发展。 应用程序层：这是唯一与用户数据直接交互的层。但是，应注意，软件应用程序不是应用程序层的组件；应用程序层负责软件用户赖以获取重要信息的协议和信息操纵。 表示层：该层的主要任务是准备信息，以便可以使用应用程序层，也就是说，第6层使信息可供消费应用程序使用。两个通信器可以使用不同的加密方法进行通信，以便将传入的数据转换为接收设备应用程序层可以理解的语法。 会话层：这是用于打开和关闭两台机器之间的通信的层。打开和关闭对应关系之间的时间段称为会话。 传输层：流控制和错误控制负责此层。传输层检查接收端是否存在错误，以确保所接收数据的完整性，如果没有，则请求重新传输。 网络层：网络层允许在两个不同的网络之间传输信息。网络层还确定信息到达其目的地的最佳物理路线。 数据链路层：数据链路层从该层收集数据包并将其分成较小的部分。像网络层一样，互连通信中的流控制和错误控制也负责数据链路层。 物理层：此层包含信息传输中涉及的物理设备，例如电线和交换机。这也是1和0的字符串，其中信息变为比特流。 TCP / IP模型： Internet协议是为网络通信建立的规则集。TCP / IP被认为是可靠的网络协议模型。它是OSI模型的精简版本。 网络接口层： 网络访问层是OSI模型中可用的数据链路层和物理层的组合。物理寻址是在此层中完成的，即源和目标的MAC地址已分配给数据包。因此，该层负责数据的物理传输。 Internet层： Internet层用于将独立的数据包发送到目的地的网络。在此层中分配了所有连接到TCP / IP网络的机器，Web服务器，节点。 传输层：它允许信息以信息图表的形式从源传送到目标主机，而没有缺陷。 应用程序层：应用程序层在三层中执行OSI模型的任务：应用程序，表示层和会话层。节点和节点之间的交互是必需的，它可以处理用户界面的要求。应用层中可用的协议是TFTP，HTTP，Telnet，SSH，NTP，DNS，NFS，FTP，SNMP，DHCP，SMTP。 OSI模型与TCP / Ip模型之间的主要区别 让我们讨论OSI模型与TCP / IP模型之间的一些主要区别 OSI知道水平方法，垂直方法称为TCP / IP方法。 OSI是独立于协议且通用的，而TCP / IP具有支持Internet开发的常规法律。 与OSI模型相比，TCP / IP模型更可靠 包被提供给OSI传输层，但是在TCP / IP情况下不能确定。 在OSI模型中，表示和会话层可用，而TCP / IP模型不包含该层。 TCP / IP实现了操作系统的功能，OSI帮助指导网络并用作参考工具 TCP / IP提供网络级别的连接功能，而OSI网络层提供连接和无连接服务。 没有其他模型是TCP / IP，而OSI则尝试匹配其他模型设计，因为它是参考。 协议可以轻松终止，而原始规则在TCP / IP模型中，而新规则可以在OSI模型中引入。 ","date":"2020-01-19","objectID":"/posts/osi%E6%A8%A1%E5%9E%8B%E4%B8%8Etcpip%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B/:0:0","tags":["OSI","TCP/IP"],"title":"OSI模型与TCPIP模型简介","uri":"/posts/osi%E6%A8%A1%E5%9E%8B%E4%B8%8Etcpip%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B/"},{"categories":["java"],"content":"java爬虫 想学会爬虫 浏览器是如何工作的 计算机网络 java的网络编程 想爬虫就要知道数据是怎么走的 当浏览器上输入网址，就会在主机host上找ip地址（域名解析DNS） 找到了，浏览器就会向这个IP地址发送请求（关心 TCP/IP的传输层 TCP协议） tcp基于流Stream 服务器就会响应你的请求发你数据包，通过端口号来识别呢一个应用程序 如何浏览器就会分析 服务器发来的数据包 1.浏览器如何工作 在⽹络上传输的只是字节流 HTTP协议 HTML JavaScript CSS ","date":"2020-01-18","objectID":"/posts/javaweb/:0:0","tags":["计算机网络","爬虫"],"title":"JavaWeb","uri":"/posts/javaweb/"},{"categories":["java"],"content":"2.相关计算机网络知识 OSIvsTCP/IP 应用层 HTTP/HTTPS DNS 传输层 TCP UDP ","date":"2020-01-18","objectID":"/posts/javaweb/:1:0","tags":["计算机网络","爬虫"],"title":"JavaWeb","uri":"/posts/javaweb/"},{"categories":["java"],"content":"3.java的网络编程 java 用什么发送请求 java 怎么样把着服务器响应（流io文件）变字符串处理，不一定要变字符串 ","date":"2020-01-18","objectID":"/posts/javaweb/:2:0","tags":["计算机网络","爬虫"],"title":"JavaWeb","uri":"/posts/javaweb/"},{"categories":["java"],"content":"同步与异步加载 服务器端⼀次返回所有的数据 服务器端返回部分数据，使⽤AJAX异步加载 ","date":"2020-01-18","objectID":"/posts/javaweb/:3:0","tags":["计算机网络","爬虫"],"title":"JavaWeb","uri":"/posts/javaweb/"},{"categories":["java"],"content":"HTTP⼊⻔与详解 HTTP method GET POST PUT DELETE… get 和 post 区别：简单来说 get 数据都在header多，几乎没body post 相关信息在header 表单或者用户数据在body header url 可见 HTTP status 1xx / 2xx / 3xx / 4xx / 5xx / 6xx 分别代表什么意思 HTTP Request headers Accept* Cookie User-Agent Referer body 表单 k-v对 HTTP Response headers Content-type Set-Cookie body JSON HTML/XML ⼆进制（图⽚/下载⽂件） cookie 是跟着域名走的 什么意思 你带有cookie的request 127:0:0:1 和 带有cookie的request localhost 是不同的(域名不一样) HTTP协议是⽆状态的 只管传数据 浏览器分析数据 ","date":"2020-01-18","objectID":"/posts/javaweb/:4:0","tags":["计算机网络","爬虫"],"title":"JavaWeb","uri":"/posts/javaweb/"},{"categories":["java"],"content":"Collection体系原理与实践 Collection体系 数组与集合的区别 ","date":"2020-01-17","objectID":"/posts/collection%E4%BD%93%E7%B3%BB%E7%9F%A5%E8%AF%86%E7%82%B9/:0:0","tags":["Collection"],"title":"Collection体系知识点","uri":"/posts/collection%E4%BD%93%E7%B3%BB%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["java"],"content":"数组 数组能存储基本数据类型和引用类型 数组的长度不可变 ","date":"2020-01-17","objectID":"/posts/collection%E4%BD%93%E7%B3%BB%E7%9F%A5%E8%AF%86%E7%82%B9/:0:1","tags":["Collection"],"title":"Collection体系知识点","uri":"/posts/collection%E4%BD%93%E7%B3%BB%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["java"],"content":"集合 集合是存对象的容器 长度可变（扩容：创建⼀个更⼤的空间，然后把原先的所有元素拷⻉过去） 只能存储对象，不可以存储基本数据类型 Collection体系 List（有序不唯一） ArrayList（用数组存） LinkedList（用链表存，增删快） Set（无序但唯一） HashSet（用哈希算法，hashcode和equals） LinkHashSet(有序) TreeSet（用二叉树/红黑树，comparable或者comparetor） Map（键值对key和value，键和值是映射关系） HashMap TreeMap HashSet比ArrayList查找速度快的多 ","date":"2020-01-17","objectID":"/posts/collection%E4%BD%93%E7%B3%BB%E7%9F%A5%E8%AF%86%E7%82%B9/:0:2","tags":["Collection"],"title":"Collection体系知识点","uri":"/posts/collection%E4%BD%93%E7%B3%BB%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["java"],"content":"Collection体系提供的常用方法： new: new ArrayList(Collection), new ArrayList() R: size()/isEmpty()/contains()/for()/stream() C/U: add()/addAll()/retainAll() D: clear()/remove()/removeAll() ","date":"2020-01-17","objectID":"/posts/collection%E4%BD%93%E7%B3%BB%E7%9F%A5%E8%AF%86%E7%82%B9/:0:3","tags":["Collection"],"title":"Collection体系知识点","uri":"/posts/collection%E4%BD%93%E7%B3%BB%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["java"],"content":"Map的常用方法： C/U: put()/putAll() R: get()/size() containsKey()/containsValue() keySet()/values()/entrySet() D: remove()/clear() Map实在是就是键为Set集合与值为Collection集合组合形成了Map 因此在调用Map.KeySet()的方法中就返回了键为Set集合 是同一个对象，Map的键和keySet()是关联的（例子：Set set=xxx.keySet(),改变了set对象同时也改变了Map的键，这就是浅拷贝） ","date":"2020-01-17","objectID":"/posts/collection%E4%BD%93%E7%B3%BB%E7%9F%A5%E8%AF%86%E7%82%B9/:0:4","tags":["Collection"],"title":"Collection体系知识点","uri":"/posts/collection%E4%BD%93%E7%B3%BB%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["java"],"content":"Collections⼯具⽅法集合 emptySet(): 等返回⼀个⽅便的空集合 synchronizedCollection: 将⼀个集合变成线程安全的 unmodifiableCollection: 将⼀个集合变成不可变的（也可以 使⽤Guava的Immutable） ","date":"2020-01-17","objectID":"/posts/collection%E4%BD%93%E7%B3%BB%E7%9F%A5%E8%AF%86%E7%82%B9/:0:5","tags":["Collection"],"title":"Collection体系知识点","uri":"/posts/collection%E4%BD%93%E7%B3%BB%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["java"],"content":"扩展知识 ","date":"2020-01-17","objectID":"/posts/collection%E4%BD%93%E7%B3%BB%E7%9F%A5%E8%AF%86%E7%82%B9/:1:0","tags":["Collection"],"title":"Collection体系知识点","uri":"/posts/collection%E4%BD%93%E7%B3%BB%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["java"],"content":"HashMap HashMap的扩容 HashMap的线程不安全性 HashMap在Java 7+后的改变：链表-\u003e红⿊树 HashMap和HashSet本质上是⼀种东⻄ HashMap在多线程下扩容会死循环(死锁) ","date":"2020-01-17","objectID":"/posts/collection%E4%BD%93%E7%B3%BB%E7%9F%A5%E8%AF%86%E7%82%B9/:1:1","tags":["Collection"],"title":"Collection体系知识点","uri":"/posts/collection%E4%BD%93%E7%B3%BB%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["java"],"content":"Collection的其他实现 Queue/Deque Vector/Stack LinkedList ConcurrentHashMap PriorityQueue ","date":"2020-01-17","objectID":"/posts/collection%E4%BD%93%E7%B3%BB%E7%9F%A5%E8%AF%86%E7%82%B9/:1:2","tags":["Collection"],"title":"Collection体系知识点","uri":"/posts/collection%E4%BD%93%E7%B3%BB%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["java"],"content":"Guava 不要重复发明轮⼦！尽量使⽤经过实战检验的类库 Lists/Sets/Maps ImmutableMap/ImmutableSet Multiset/Multimap BiMap ","date":"2020-01-17","objectID":"/posts/collection%E4%BD%93%E7%B3%BB%E7%9F%A5%E8%AF%86%E7%82%B9/:1:3","tags":["Collection"],"title":"Collection体系知识点","uri":"/posts/collection%E4%BD%93%E7%B3%BB%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["java"],"content":"maven笔记 ","date":"2020-01-15","objectID":"/posts/maven%E5%8C%85%E7%AE%A1%E7%90%86/:0:0","tags":["包管理","Maven"],"title":"Maven包管理","uri":"/posts/maven%E5%8C%85%E7%AE%A1%E7%90%86/"},{"categories":["java"],"content":"目录 什么是包 包的故事 包管理 Maven包管理 包冲突问题 没有Maven前的解决办法 Maven解决包冲突办法 项目缺失包解决办法 什么是包（jar） 很简单就相当于zip，类多了就用jar压缩 包的故事 JVM是一个很耿直的虚拟机。为什么说JVM很耿直，因为JVM的工作被设计的很简单 执行一个类的字节码 当'1’的过程遇到新的类，就会加载它 问题 那么你有没有想过一个问题，那些类JVM会在哪里找，这些类终不会无中生有吧！ 项目需要某个jar包，你有没有试过你复制了一个jar包到项目，但还是没有卵用！！！ 答案 这就涉及到了java编译运行时 Jvm会帮你创建一个命令，命令的其中一个参数 -classpath 全包名XXX.... JVM遇到一个新的类就好去-classpath 上找对应的jar包里面的类，找到就执行，否则报错。 传递性依赖：简单来说就是你用的jar包里面又用别的jar包，然后别的jar包又用另一个jar包。 classpath hell：全限定类名是类的唯一标识 (例子：org.apache.commons.lang3) 但多个同名类同时出现在Classpath中，就是噩梦开始（包冲突问题） 包管理 使用第三方类， 包管理本质就是告诉JVM如何找到所需的第三方库 以及成功解决其中的冲突问题（很困难） Maven包管理 约定优于配置 （约定能通用，配置再好可能只是个人不能很好团队开发） Maven远远不止是包管理工具 Maven中央仓库 按照一定约定存储包(像图书馆一样管理书籍) \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter-engine\u003cartifact\u003e \u003cversion\u003e5.4.2\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e Maven本地仓库 默认位于~/.m2 下载第三方包进行缓存 Maven的包 按照约定为所有的包编号，⽅便检索 groupId/artifactId/version 语义化版本 SNAPSHOT快照版本 传递性依赖的⾃动管理 原则：绝对不允许最终的classpath出现同名不同版本的jar包 依赖冲突的解决：原则：最近的胜出 依赖的scope compile：生产代码的依赖 test：只有测试代码的依赖，例如测试框架JUnit provided：编译时需要，但是运⾏时由容器提供，典型如Servlet API runtime：编译时候不需要，运⾏时候需要，典型如mysql,connector等JDBC的maven本地仓库 包冲突问题 最先声明的原则： -classpath org.apache.commons.lang3(版本1):org.apache.commons.lang3(版本2) 多个同名类同时出现在Classpath中，JVM在-classpath按顺序找，找到哪一个先就用哪一个（就会用版本1 ） 你本想用版本2（修复了版本1bug），之前导入版本1忘记删后面导入版本2，但JVM用了版本1，这样就是有bug问题。 常见的包冲突异常如下： AbstractMethodError NoClassDefFoundError ClassNotFoundException LinkageError 没有Maven前的解决办法 手写命令行进行编译 不完整的简单例子： javac -classpath jar包名:jar包名:jar包名 一个一个依赖全部打上去，还要搞清楚那几个包中的类冲突并进行处理 Maven解决包冲突办法 清楚那些相同类名，看依赖树（有三种方法） idea右侧Maven的可视化视图 终端bash运行mvn dependency:tree idea下载Maven Helper插件查看依赖树 采用某一个版本 用最近原则 强行解除依赖关系 最先原则 项目缺失包解决办法 建议最好用google搜索 “jar包名 Maven” 搜索到的依赖加到pom.xml，刷新maven。","date":"2020-01-15","objectID":"/posts/maven%E5%8C%85%E7%AE%A1%E7%90%86/:0:1","tags":["包管理","Maven"],"title":"Maven包管理","uri":"/posts/maven%E5%8C%85%E7%AE%A1%E7%90%86/"}]